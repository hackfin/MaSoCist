/* NEO430 simple SoC setup
 *
 * Do not edit this file if it has a .vhdl extension, all changes will be
 * void!
 *
 *
 */

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library neo430;
use neo430.neo430_package.all;

library work;
use work.busdef.all;
use work.global_config.all;
use work.memory_initialization.all;
use work.ram.all;

#include "../../include/generated/autoconf.h"

entity SoC is
	port (
		clk			    : in  std_ulogic; -- global clock, rising edge

#ifdef CONFIG_UART
		uart_tx         : out    std_logic;
		uart_rx         : in     std_logic;
		-- uartio_rxirq    : out    std_logic;
#endif

#ifdef CONFIG_SPI
		spi_cs         : out    std_logic;
		spi_sclk       : out    std_logic;
		spi_mosi       : out    std_logic;
		spi_miso       : in     std_logic;
#endif

#ifdef CONFIG_GPIO
		gpio           : inout  unsigned(CONFIG_NUM_GPIO * 16-1 downto 0);
#endif

		-- Interrupts:
		nmi_i          : in  std_ulogic; -- external interrupt request line
		-- irq_ack_o   : out std_ulogic  -- external interrupt request acknowledge
		reset          : in  std_ulogic -- global reset, async, LOW-active
	);
end SoC;

architecture neo430_top_rtl of SoC is
	constant WORD_SIZE : natural := 16;
	-- generators --
	signal rst_gen			: std_ulogic_vector(03 downto 0) := (others => '0'); -- perform reset on bitstream upload
	signal rst_gen_sync : std_ulogic_vector(01 downto 0);
	signal ext_rst			: std_ulogic;
	signal sys_rst			: std_ulogic;
	signal wdt_rst			: std_ulogic;
	-- signal timer_cg_en	: std_ulogic;
	-- signal usart_cg_en	: std_ulogic;
	signal wdt_cg_en		: std_ulogic;
	-- signal pwm_cg_en		: std_ulogic;

#ifdef CONFIG_GPIO
	signal gpio_dir        : std_logic_vector(CONFIG_NUM_GPIO * 16-1 downto 0);
	signal gpio_in         : std_logic_vector(CONFIG_NUM_GPIO * 16-1 downto 0);
	signal gpio_out        : std_logic_vector(CONFIG_NUM_GPIO * 16-1 downto 0);
#endif

	subtype ramaddr16_t is unsigned(CONFIG_BRAM_ADDR_WIDTH-2 downto 1);

	type cpu_bus_t is record
		rd_en : std_ulogic;
		wr_en : std_ulogic_vector(01 downto 0);
		addr	: std_ulogic_vector(15 downto 0);
		rdata : std_ulogic_vector(15 downto 0);
		wdata : std_ulogic_vector(15 downto 0);
	end record;

	-- main CPU communication bus --
	signal cpu_bus	: cpu_bus_t;
	-- signal io_acc		: std_ulogic;
	-- signal io_wr_en : std_ulogic;
	-- signal io_rd_en : std_ulogic;

	-- Wishbone interfacing:

	signal wb_perio_wr    : wb_WritePort;
	signal wb_perio_rd    : wb_ReadPort;
	signal bus_we         : std_ulogic;
	signal perio_ce       : std_ulogic;
	signal perio_ce_d     : std_ulogic;

	signal io_32_addr      : unsigned(32-1 downto 0);
	signal io_16_wdata     : unsigned(16-1 downto 0);
	signal io_16_rdata     : unsigned(16-1 downto 0);

	-- Program+rodata+stack BRAM
	-- Port A
	signal imem_a_we     : std_logic := '0';
	signal imem_a_addr   : ramaddr16_t := (others => '0');
	signal imem_a_write  : unsigned(WORD_SIZE-1 downto 0) := (others => 'X');
	signal imem_a_read   : unsigned(WORD_SIZE-1 downto 0);
	-- Port B
	-- signal imem_b_we     : std_logic := '0';
	signal imem_b_addr   : ramaddr16_t;
	-- signal imem_b_write  : unsigned(WORD_SIZE-1 downto 0) := (others => 'X');
	signal imem_b_read   : unsigned(WORD_SIZE-1 downto 0);

	-- Data (volatile) memory
	-- Port A
--	signal dmem_a_we     : std_logic := '0';
--	signal dmem_a_addr   : ramaddr16_t;
--	signal dmem_a_write  : unsigned(WORD_SIZE-1 downto 0) := (others => 'X');
--	signal dmem_a_read   : unsigned(WORD_SIZE-1 downto 0);
--	-- Port B
--	signal dmem_b_we     : std_logic;
--	signal dmem_b_addr   : ramaddr16_t;
--	signal dmem_b_write  : unsigned(WORD_SIZE-1 downto 0);
--	signal dmem_b_read   : unsigned(WORD_SIZE-1 downto 0);

	-- read-back data buses --
	signal wdt_rdata			 : std_ulogic_vector(15 downto 0);
	-- signal timer_rdata		 : std_ulogic_vector(15 downto 0);
	-- signal usart_rdata		 : std_ulogic_vector(15 downto 0);

	-- interrupt system --
	signal irq			 : std_ulogic_vector(03 downto 0);
	signal irq_ack	 : std_ulogic_vector(03 downto 0);
	-- signal timer_irq : std_ulogic;
	-- signal usart_irq : std_ulogic;
	-- signal gpio_irq  : std_ulogic;
	signal xirq_sync : std_ulogic_vector(01 downto 0);

	-- misc --
	signal imem_up_en : std_ulogic;

begin
	-- Reset Generator ----------------------------------------------------------
	-- -----------------------------------------------------------------------------
	reset_generator: process(reset, clk)
	begin
		if (reset = '1') then
			rst_gen <= (others => '0');
		elsif rising_edge(clk) then
			rst_gen <= rst_gen(rst_gen'left-1 downto 0) & '1';
		end if;
	end process reset_generator;

	-- one extra sync ff to prevent weird glitches on the reset net
	-- and another one to avoid metastability
	reset_generator_sync_ff: process(clk)
	begin
		if rising_edge(clk) then
			rst_gen_sync <= rst_gen_sync(0) & rst_gen(rst_gen'left);
		end if;
	end process reset_generator_sync_ff;

	ext_rst <= rst_gen_sync(1);
	sys_rst <= ext_rst and wdt_rst;


	neo430_cpu_inst: neo430_cpu
	generic map (
		BOOTLD_USE	=> CONFIG_NEO430_DADD,
		IMEM_AS_ROM => CONFIG_NEO430_IMEM_RO
	)
	port map (
		-- global control --
		clk_i			 => clk,
		rst_i			 => sys_rst,
		-- memory interface --
		mem_rd_o   => cpu_bus.rd_en,    -- memory read
		mem_imwe_o => imem_up_en,       -- allow writing to IMEM
		mem_wr_o   => cpu_bus.wr_en,    -- memory write
		mem_addr_o => cpu_bus.addr,	    -- address
		mem_data_o => cpu_bus.wdata,    -- write data
		mem_data_i => cpu_bus.rdata,    -- read data
		-- interrupt system --
		irq_i      => irq               -- interrupt request lines
	 );

#ifdef SYNTHESIS_GHDL

imem: DPRAM16_init_hex_ce
	generic map (
		ADDR_W => CONFIG_BRAM_ADDR_WIDTH-2
		-- INIT_DATA => ram16_init_t(BOOTROM_INIT)
	)
	port map (
		a_clk     => clk,
		a_ce      => '1',
		a_we      => '0', -- Write not supported
		a_addr    => imem_a_addr,
		a_write   => (others => 'X'),
		a_read    => imem_a_read,
		--
		b_clk     => clk,
		b_ce      => '1',
		b_we      => '0',
		b_addr    => imem_b_addr,
		b_write   => (others => 'X'),
		b_read    => imem_b_read
	);

#else

imem: DPRAM16_init_ce
	generic map (
		ADDR_W => CONFIG_BRAM_ADDR_WIDTH-2,
		INIT_DATA => ram16_init_t(BOOTROM_INIT)
	)
	port map (
		clk       => clk,
		a_ce      => '1',
		a_we      => '0', -- Write not supported
		a_addr    => imem_a_addr,
		a_write   => (others => 'X'),
		a_read    => imem_a_read,
		--
		b_ce      => '1',
		b_we      => '0',
		b_addr    => imem_b_addr,
		b_write   => (others => 'X'),
		b_read    => imem_b_read
	);



#endif

-- dmem: entity work.DPRAM_sync
-- 	generic map (
-- 		ADDR_W => CONFIG_NEO430_DMEM_WIDTH-1
-- 	)
-- 	port map (
-- 		clk       => clk,
-- 		a_we      => dmem_a_we,
-- 		a_addr    => dmem_a_addr,
-- 		a_write   => dmem_a_write,
-- 		a_read    => dmem_a_read,
-- 		--
-- 		b_we      => dmem_b_we,
-- 		b_addr    => dmem_b_addr,
-- 		b_write   => dmem_b_write,
-- 		b_read    => dmem_b_read
-- 	);


#ifdef CONFIG_WISHBONE

	------------------------------------------------
	-- Wishbone bridge:

	io_32_addr <= x"0000" & unsigned(cpu_bus.addr);
	io_16_wdata <= unsigned(cpu_bus.wdata);

	imem_b_addr <= unsigned(cpu_bus.addr(CONFIG_BRAM_ADDR_WIDTH-2 downto 1));

	with perio_ce_d select
		cpu_bus.rdata <= std_ulogic_vector(io_16_rdata) when '1',
		                 std_ulogic_vector(imem_b_read)       when others;

	-- HI and LO byte WE's are ORed
	bus_we <= cpu_bus.wr_en(0) or cpu_bus.wr_en(1);


bus_bridge:
	entity work.wb2zpu
	generic map (WORD_SIZE => 16)
	port map (
		clk         => clk,
		addr        => io_32_addr,
		we          => bus_we,
		re          => cpu_bus.rd_en,
		din         => io_16_wdata,
		dout        => io_16_rdata,
		wb_in       => wb_perio_rd,
		wb_out      => wb_perio_wr,
		reset       => reset
	);

#else
#error "Other than wishbone bus not supported"
#endif

----------------------------------------------------------------------------
perio:
	entity work.mmr_perio

	port map (
 		bus_in          => wb_perio_wr,
 		bus_out         => wb_perio_rd,
		ce              => perio_ce,
		byte_we_high    => cpu_bus.wr_en(1),
		byte_we_low     => cpu_bus.wr_en(0),
		uartio_tx       => uart_tx,
		uartio_rx       => uart_rx,
		uartio_rxirq    => open,

#ifdef CONFIG_GPIO
		mio_gpio_in     => gpio_in,
		mio_gpio_out    => gpio_out,
		mio_gpio_dir    => gpio_dir,
#endif

#ifdef CONFIG_SPI
		spio_cs         => spi_cs,
		spio_sclk       => spi_sclk,
		spio_mosi       => spi_mosi,
		spio_miso       => spi_miso,
#endif
		reset           => '0',
		clk             => clk

	);

#ifdef CONFIG_GPIO

	gpio_in <= std_logic_vector(gpio);

gpio_direction:
	for i in 0 to CONFIG_NUM_GPIO*16-1 generate
		gpio(i) <= gpio_out(i) when gpio_dir(i) = '1' else 'Z';
	end generate;
#endif


perio_select_delay:
	process(clk)
	begin
		if rising_edge(clk) then
			perio_ce_d <= perio_ce;
		end if;
	end process;

	perio_ce <= '1' when cpu_bus.addr(15) = '1' else '0'; -- This is fixed

	-- sync for external IRQ --
	external_irq_sync: process(clk)
	begin
		if rising_edge(clk) then
			xirq_sync <= xirq_sync(0) & nmi_i;
		end if;
	end process external_irq_sync;

	-- interrupt priority assignment --
	irq(0) <= '0';		-- timer match (highest priority)
	irq(1) <= '0';		-- UART Rx available [OR] UART Tx done [OR] SPI RTX done
	irq(2) <= '0';			-- GPIO input pin change
	irq(3) <= xirq_sync(1); -- external interrupt request (lowest priority)

	-- external interrupt acknowledge --
	-- irq_ack_o <= irq_ack(3); -- the internal irq sources do not require an acknowledge




	-- io_acc	 <= '1' when (cpu_bus.addr(15 downto index_size_f(io_size_c)) = io_base_c(15 downto index_size_f(io_size_c))) else '0';
	-- io_rd_en <= cpu_bus.rd_en and io_acc;
	-- io_wr_en <= (cpu_bus.wr_en(0) or cpu_bus.wr_en(1)) and io_acc;


	wdt_rdata <= (others => '0');
	wdt_rst		<= '1';
	wdt_cg_en <= '0';


end neo430_top_rtl;
