/* NEO430 simple SoC setup
 *
 * Do not edit this file if it has a .vhdl extension, all changes will be
 * void!
 *
 *
 */

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library neo430;
use neo430.neo430_package.all;

library work;
use work.busdef.all;
use work.global_config.all;
use work.memory_initialization.all;
use work.ram.all;

#include "../../include/generated/autoconf.h"

entity SoC is
	port (
		clk			 : in  std_ulogic; -- global clock, rising edge
		reset			 : in  std_ulogic; -- global reset, async, LOW-active

#ifdef CONFIG_UART
		uartio_tx       : out    std_logic;
		uartio_rx       : in     std_logic;
		uartio_rxirq    : out    std_logic;
#endif

#ifdef CONFIG_SPI
		spio_cs         : out    std_logic;
		spio_sclk       : out    std_logic;
		spio_mosi       : out    std_logic;
		spio_miso       : in     std_logic;
#endif

		-- Interrupts:
		irq_i			 : in  std_ulogic; -- external interrupt request line
		irq_ack_o  : out std_ulogic  -- external interrupt request acknowledge
	);
end SoC;

architecture neo430_top_rtl of SoC is
	constant WORD_SIZE : natural := 16;
	-- generators --
	signal rst_gen			: std_ulogic_vector(03 downto 0) := (others => '0'); -- perform reset on bitstream upload
	signal rst_gen_sync : std_ulogic_vector(01 downto 0);
	signal ext_rst			: std_ulogic;
	signal sys_rst			: std_ulogic;
	signal wdt_rst			: std_ulogic;
	signal timer_cg_en	: std_ulogic;
	signal usart_cg_en	: std_ulogic;
	signal wdt_cg_en		: std_ulogic;
	signal pwm_cg_en		: std_ulogic;


	subtype ramaddr16_t is unsigned(CONFIG_BRAM_ADDR_WIDTH-2 downto 1);

	type cpu_bus_t is record
		rd_en : std_ulogic;
		wr_en : std_ulogic_vector(01 downto 0);
		addr	: std_ulogic_vector(15 downto 0);
		rdata : std_ulogic_vector(15 downto 0);
		wdata : std_ulogic_vector(15 downto 0);
	end record;

	-- main CPU communication bus --
	signal cpu_bus	: cpu_bus_t;
	signal io_acc		: std_ulogic;
	signal io_wr_en : std_ulogic;
	signal io_rd_en : std_ulogic;

	-- Wishbone interfacing:

	signal wb_perio_wr    : wb_WritePort;
	signal wb_perio_rd    : wb_ReadPort;
	signal bus_we         : std_ulogic;
	signal perio_ce       : std_ulogic;
	signal perio_ce_d     : std_ulogic;

	signal io_32_addr      : unsigned(32-1 downto 0);
	signal io_16_wdata     : unsigned(16-1 downto 0);
	signal io_16_rdata     : unsigned(16-1 downto 0);

	-- Program+rodata+stack BRAM
	-- Port A
	signal imem_a_we     : std_logic := '0';
	signal imem_a_addr   : ramaddr16_t;
	signal imem_a_write  : unsigned(WORD_SIZE-1 downto 0) := (others => 'X');
	signal imem_a_read   : unsigned(WORD_SIZE-1 downto 0);
	-- Port B
	signal imem_b_we     : std_logic;
	signal imem_b_addr   : ramaddr16_t;
	signal imem_b_write  : unsigned(WORD_SIZE-1 downto 0);
	signal imem_b_read   : unsigned(WORD_SIZE-1 downto 0);

	-- Data (volatile) memory
	-- Port A
--	signal dmem_a_we     : std_logic := '0';
--	signal dmem_a_addr   : ramaddr16_t;
--	signal dmem_a_write  : unsigned(WORD_SIZE-1 downto 0) := (others => 'X');
--	signal dmem_a_read   : unsigned(WORD_SIZE-1 downto 0);
--	-- Port B
--	signal dmem_b_we     : std_logic;
--	signal dmem_b_addr   : ramaddr16_t;
--	signal dmem_b_write  : unsigned(WORD_SIZE-1 downto 0);
--	signal dmem_b_read   : unsigned(WORD_SIZE-1 downto 0);

	-- read-back data buses --
	signal rom_rdata			 : std_ulogic_vector(15 downto 0);
	signal ram_rdata			 : std_ulogic_vector(15 downto 0);
	signal muldiv_rdata		 : std_ulogic_vector(15 downto 0);
	signal boot_rdata			 : std_ulogic_vector(15 downto 0);
	signal wdt_rdata			 : std_ulogic_vector(15 downto 0);
	signal timer_rdata		 : std_ulogic_vector(15 downto 0);
	signal usart_rdata		 : std_ulogic_vector(15 downto 0);
	signal gpio_rdata			 : std_ulogic_vector(15 downto 0);
	signal crc_rdata			 : std_ulogic_vector(15 downto 0);
	signal cfu_rdata			 : std_ulogic_vector(15 downto 0);
	signal pwm_rdata			 : std_ulogic_vector(15 downto 0);
	signal trng_rdata			 : std_ulogic_vector(15 downto 0);

	-- interrupt system --
	signal irq			 : std_ulogic_vector(03 downto 0);
	signal irq_ack	 : std_ulogic_vector(03 downto 0);
	signal timer_irq : std_ulogic;
	signal usart_irq : std_ulogic;
	signal gpio_irq  : std_ulogic;
	signal xirq_sync : std_ulogic_vector(01 downto 0);

	-- misc --
	signal imem_up_en : std_ulogic;

begin
	-- Reset Generator ----------------------------------------------------------
	-- -----------------------------------------------------------------------------
	reset_generator: process(reset, clk)
	begin
		if (reset = '1') then
			rst_gen <= (others => '0');
		elsif rising_edge(clk) then
			rst_gen <= rst_gen(rst_gen'left-1 downto 0) & '1';
		end if;
	end process reset_generator;

	-- one extra sync ff to prevent weird glitches on the reset net
	-- and another one to avoid metastability
	reset_generator_sync_ff: process(clk)
	begin
		if rising_edge(clk) then
			rst_gen_sync <= rst_gen_sync(0) & rst_gen(rst_gen'left);
		end if;
	end process reset_generator_sync_ff;

	ext_rst <= rst_gen_sync(1);
	sys_rst <= ext_rst and wdt_rst;



	neo430_cpu_inst: neo430_cpu
	generic map (
		BOOTLD_USE	=> CONFIG_NEO430_DADD,
		IMEM_AS_ROM => CONFIG_NEO430_IMEM_RO
	)
	port map (
		-- global control --
		clk_i			 => clk,						-- global clock, rising edge
		rst_i			 => sys_rst,					-- global reset, low-active, async
		-- memory interface --
		mem_rd_o   => cpu_bus.rd_en,		-- memory read
		mem_imwe_o => imem_up_en,				-- allow writing to IMEM
		mem_wr_o   => cpu_bus.wr_en,		-- memory write
		mem_addr_o => cpu_bus.addr,			-- address
		mem_data_o => cpu_bus.wdata,		-- write data
		mem_data_i => cpu_bus.rdata,		-- read data
		-- interrupt system --
		irq_i			 => irq,							-- interrupt request lines
		irq_ack_o  => irq_ack						-- IRQ acknowledge
	);

imem: entity work.DPRAM16_init
	generic map (
		ADDR_W => CONFIG_BRAM_ADDR_WIDTH-2,
		INIT_DATA => ram16_init_t(BOOTROM_INIT)
	)
	port map (
		clk       => clk,
		a_we      => imem_a_we,
		a_addr    => imem_a_addr,
		a_write   => imem_a_write,
		a_read    => imem_a_read,
		--
		b_we      => imem_b_we,
		b_addr    => imem_b_addr,
		b_write   => imem_b_write,
		b_read    => imem_b_read
	);

-- dmem: entity work.DPRAM_sync
-- 	generic map (
-- 		ADDR_W => CONFIG_NEO430_DMEM_WIDTH-1
-- 	)
-- 	port map (
-- 		clk       => clk,
-- 		a_we      => dmem_a_we,
-- 		a_addr    => dmem_a_addr,
-- 		a_write   => dmem_a_write,
-- 		a_read    => dmem_a_read,
-- 		--
-- 		b_we      => dmem_b_we,
-- 		b_addr    => dmem_b_addr,
-- 		b_write   => dmem_b_write,
-- 		b_read    => dmem_b_read
-- 	);


#ifdef CONFIG_WISHBONE

	------------------------------------------------
	-- Wishbone bridge:

	io_32_addr <= x"0000" & unsigned(cpu_bus.addr);
	io_16_wdata <= unsigned(cpu_bus.wdata);

	imem_b_addr <= unsigned(cpu_bus.addr(CONFIG_BRAM_ADDR_WIDTH-2 downto 1));

	with perio_ce_d select
		cpu_bus.rdata <= std_ulogic_vector(io_16_rdata) when '1',
		                 std_ulogic_vector(imem_b_read)       when others;

	-- HI and LO byte WE's are ORed
	bus_we <= cpu_bus.wr_en(0) or cpu_bus.wr_en(1);

bus_bridge:
	entity work.wb2zpu
	generic map (WORD_SIZE => 16)
	port map (
		clk         => clk,
		addr        => io_32_addr,
		we          => bus_we,
		re          => cpu_bus.rd_en,
		din         => io_16_wdata,
		dout        => io_16_rdata,
		wb_in       => wb_perio_rd,
		wb_out      => wb_perio_wr,
		reset       => reset
	);

#else
#error "Other than wishbone bus not supported"
#endif

----------------------------------------------------------------------------
perio:
	entity work.mmr_perio

	port map (
 		bus_in          => wb_perio_wr,
 		bus_out         => wb_perio_rd,
		ce              => perio_ce,
		byte_we_high    => cpu_bus.wr_en(1),
		byte_we_low     => cpu_bus.wr_en(0),
		uartio_tx       => uartio_tx,
		uartio_rx       => uartio_rx,
		uartio_rxirq    => uartio_rxirq,
		spio_cs         => spio_cs,
		spio_sclk       => spio_sclk,
		spio_mosi       => spio_mosi,
		spio_miso       => spio_miso,

		reset           => '0',
		clk             => clk

	);

perio_select_delay:
	process(clk)
	begin
		if rising_edge(clk) then
			perio_ce_d <= perio_ce;
		end if;
	end process;

	perio_ce <= '1' when cpu_bus.addr(15) = '1' else '0'; -- This is fixed

	-- sync for external IRQ --
	external_irq_sync: process(clk)
	begin
		if rising_edge(clk) then
			xirq_sync <= xirq_sync(0) & irq_i;
		end if;
	end process external_irq_sync;

	-- interrupt priority assignment --
	irq(0) <= '0';		-- timer match (highest priority)
	irq(1) <= '0';		-- UART Rx available [OR] UART Tx done [OR] SPI RTX done
	irq(2) <= '0';			-- GPIO input pin change
	irq(3) <= xirq_sync(1); -- external interrupt request (lowest priority)

	-- external interrupt acknowledge --
	irq_ack_o <= irq_ack(3); -- the internal irq sources do not require an acknowledge




	io_acc	 <= '1' when (cpu_bus.addr(15 downto index_size_f(io_size_c)) = io_base_c(15 downto index_size_f(io_size_c))) else '0';
	io_rd_en <= cpu_bus.rd_en and io_acc;
	io_wr_en <= (cpu_bus.wr_en(0) or cpu_bus.wr_en(1)) and io_acc;


	wdt_rdata <= (others => '0');
	wdt_rst		<= '1';
	wdt_cg_en <= '0';


end neo430_top_rtl;
