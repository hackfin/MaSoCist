--
-- EVDK ECP5 top level module
--
--
-- 1/2017  Martin Strubel <hackfin@section5.ch>
--
-- Changes to this file WILL BE VOID if it has a .vhdl extension!
-- Edit the corresponding .chdl file instead.

#include "../../include/generated/autoconf.h"
// Hack to not substitute this one as it will not be understood:
#undef CONFIG_TAPCLK_PERIOD

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

library ECP5UM;
	use ECP5UM.components.all;

library work;
	use work.bb_components.all;

library work;
	use work.stdtap.all;
	use work.global_config.all;
	use work.system_map.all;

entity evdk_ecp5_top is
	generic ( SIMULATION : boolean := false );
	port (
#ifndef SYNTHESIS_GHDL
		tck         : in  std_logic;
		tms         : in  std_logic;
		tdi         : in  std_logic;
		tdo         : out std_logic;
#endif
		-- clk_out     : out  std_logic;

		spi_miso  : in  std_logic;
		spi_mosi  : out std_logic;
		spi_cs    : out std_logic;

		vp_reset     : out std_logic;	
		cl_reset     : out std_logic;	
		cs_sda      : inout std_logic_vector(1 downto 0);	
		cs_scl      : inout std_logic_vector(1 downto 0);
		-- Video port 1
		vp1_data     : in   std_logic_vector(9 downto 0);
		vp1_lv       : in   std_logic;
		vp1_fv       : in   std_logic;
		vp1_clk      : in   std_logic;

		txd_uart    : in std_logic;	  -- FT2232 -> CPU
		rxd_uart    : out std_logic;  -- CPU    -> FT2232

		oled        : out  std_logic_vector(7 downto 0);

		-- MAC I/O
#ifdef CONFIG_MAC
		phy_rgmii_txclk      : out std_logic;
		phy_rgmii_txctl      : out std_logic;
		phy_rgmii_txd        : out std_logic_vector(3 downto 0);
		phy_rgmii_rxclk      : in std_logic;
		phy_rgmii_rxctl      : in std_logic;
		phy_rgmii_rxd        : in std_logic_vector(3 downto 0);

		phy_rgmii_refclk     : in std_logic;

		ts_mac_coremdc       : out std_logic;
		ts_mac_coremdio      : inout std_logic;
		-- eth_rst_n            : out std_logic;
		-- hw_config            : out std_logic;
#endif

		-- Debugging:
		hdr          : out std_logic_vector(7 downto 0);

		reset_n      : in   std_logic;
		clk_100m_i   : in   std_logic;
		clk_27m_i    : in   std_logic

	);
end entity evdk_ecp5_top;


architecture behaviour of evdk_ecp5_top is

	signal mclk           : std_logic;
	signal mclk_locked    : std_logic;

	signal sys_ctrl   : sys_WritePort;
	signal sys_stat   : sys_ReadPort;

	signal irq_in        : std_logic := '0';
	signal int_resetn : std_logic;
	signal phy_lowpwr : std_logic;

	signal pvi_data       : std_logic_vector(15 downto 0);

	signal tap2core       : tap_out_rec := (
		tapclk => '0',
		jtag_reset => '0',
		core_reset => '0',
		emuexec => '0',
		emumask => '0',
		emurequest => '0',
		emudata => (others => '0'),
		emuir => (others => '0'),
		reg => (others => '0'),
		craddr => (others => '0')
	);
	signal core2tap       : tap_in_rec;

	-- TODO
	-- signal uart_iosel     : std_logic;
	signal spi_ts         : std_logic;
	signal spi_sclk       : std_logic;
	signal spi_mclk_dummy : std_logic;

#ifdef CONFIG_SPI
	signal spi_cs_int     : std_logic;
#endif

	signal comb_reset     : std_logic;
	signal delayed_reset  : std_logic;
	signal reset_delay    : unsigned(3 downto 0);
	signal phy_reset      : std_logic;
	signal cpu_reset      : std_logic;
	signal tap_reset      : std_logic;

	-- GPIOs:
	-- Set to defined state for simulation:
	signal gpio           : unsigned(CONFIG_NUM_GPIO*16-1 downto 0);
	signal cfg            : std_logic_vector(7 downto 0);
	signal status         : unsigned(7 downto 0);

	-- Debugging:
	signal uart_loopback  : std_logic;

	-- MAC clocks:
	signal mac_clk125     : std_logic;
	signal mac_mclk       : std_logic;

#ifdef SYNTHESIS_GHDL
		signal tck         : std_logic := '0';
		signal tms         : std_logic := '0';
		signal tdi         : std_logic := '0';
		signal tdo         : std_logic := '0';
#endif


begin
	spi_cs <= spi_cs_int;
	spi_ts <= spi_cs_int; -- Use CS for tristate

-- User SPI access via USRMCLK ECP5 primitive:
	usrmclk_inst: usrmclk_wrapper
		port map (usrmclki => spi_sclk, usrmclkts => spi_ts,
			spi_mclk_dummy => spi_mclk_dummy);

	comb_reset <= (not reset_n) or (not mclk_locked);
	-- hw_config <= '0';

	-- phy_addr <= "00000";
	-- phy_rst_n <= not phy_reset;

	-- clk_out <= mclk;

	-- gsr_inst: GSR port map (reset_n);

macclk_pll: pll_mac
    port map (
        CLKI    =>  clk_100m_i,
        CLKOP   =>  mac_clk125,
        CLKOS   =>  mclk, -- 25 Mhz
        CLKOS2  =>  open,
        LOCK    =>  mclk_locked
	);

-- mclk_pll: entity work.pll_mclk
--     port map (
--         CLKI   =>  clk_27m_i,
--         CLKOP  =>  mclk,
--         LOCK   =>  mclk_locked
-- 	);


-- We run a delayed reset for the CPU, as there might be race conditions
-- with the TAP.

delayed_cpu_reset:
	process (comb_reset, mclk)
	begin
		if comb_reset = '1' then
			reset_delay	<= x"f";
			delayed_reset <= '1';
		elsif rising_edge(mclk) then
			if reset_delay /= x"0" then
				reset_delay <= reset_delay - 1;
			else
				delayed_reset <= '0';
			end if;
		end if;
	end process;

----------------------------------------------------------------------------
-- SoC CPU

maybe_hwtap:
if not SIMULATION generate

hwtap: entity work.ECP5_TAP
	port map (
		reset       => '0', -- startup reset
		tck         => tck,
		tms         => tms,
		tdi         => tdi,
		tdo         => tdo,
		-- Core <-> TAP signals:
		tin         => core2tap,
		tout        => tap2core
	);

end generate;

-- synthesis translate_off

maybe_swtap:
if SIMULATION generate
	swtap: VirtualTAP_DIRECT
	generic map ( IDCODE => CONFIG_TAP_ID,
		INS_NOP => x"0000000b",
		TCLK_PERIOD => CONFIG_TAPCLK_PERIOD )
	port map (
		-- Core <-> TAP signals:
		tin         => core2tap,
		tout        => tap2core
	);
end generate;

-- synthesis translate_on

	cpu_reset <= tap2core.core_reset or delayed_reset;
	tap_reset <= comb_reset;

	-- pvi_data <= x"00" & vp0_data(11 downto 4);
	 pvi_data <= x"00" & vp1_data(9 downto 2); -- IMX214 upper 8 bits

soc: entity work.SoC
	port map (
		clk        => mclk,
		pclk       => vp1_clk,
		tap_reset  => tap_reset,
		reset      => cpu_reset,
		nmi_i      => '0',

		perio_rst  => '0',

		-- Emulation pins:
		tin          => tap2core,
		tout         => core2tap,

		irq0       => irq_in,
		gpio       => gpio,
		-- pwm       => pwm(CONFIG_NUM_TMR-1 downto 0),

		spi_sclk         => spi_sclk,
		spi_cs           => spi_cs_int,
		spi_mosi         => spi_mosi,
		spi_miso         => spi_miso,

		twi_sda          => cs_sda(0),
		twi_scl          => cs_scl(0),

#ifdef CONFIG_VIDEO
		video_resetn     => int_resetn,
	
		pvi_data         => pvi_data,
		pvi_lv           => vp1_lv,
		pvi_fv           => vp1_fv,
#endif

#ifdef CONFIG_MAC
		mac_mclk         => mac_mclk,
		mac_clk125       => mac_clk125,
		mac_gbit_en      => open,

		macio_rgmii_txclk  => phy_rgmii_txclk,
		macio_rgmii_txd   => phy_rgmii_txd,
		macio_rgmii_tc   => phy_rgmii_txctl,
		macio_rgmii_rxclk   => phy_rgmii_rxclk,
		macio_rgmii_rxd   => phy_rgmii_rxd,
		macio_rgmii_rc   => phy_rgmii_rxctl,

		macio_mdc        => ts_mac_coremdc,
		macio_mdio       => ts_mac_coremdio,
		macio_phyrst     => phy_reset,
		macio_phy_lowpwr => phy_lowpwr,

		mii_col    => '0',
		mii_crs    => '0',
#endif

		-- sysconfig     => cfg,
		-- led_status    => status,

		uart_tx => rxd_uart,
		uart_rx => txd_uart
	);

-- XXX temporary TWI FIX
	cs_sda(1) <= 'H';
	cs_scl(1) <= 'H';


-- Debugging:
	-- vp1_data(0) <= mii_rx_clk_i;
	-- vp1_data(1) <= mii_tx_clk_i;
	-- vp1_data(2) <= mii_rx_dv_i; 
	-- vp1_data(3) <= '0'; 
	-- vp1_data(4) <= mclk; 

	-- Video and CrossLink reset:
	cl_reset <= gpio(15);
	vp_reset <= int_resetn;
--	cs0_sda <= sda(0);
--	cs0_scl <= scl(0);
--	cs1_sda <= sda(1);
--	cs1_scl <= scl(1);
	oled(0) <= not int_resetn; -- low active LED
	oled(7) <= not core2tap.emuack;
	oled(6 downto 1) <= not std_logic_vector(gpio(5 downto 0));
	-- phy_lowpwr_o <= not phy_lowpwr;

	-- vp1_mclk <= vp0_clk;

	-- Debugging:
	hdr  <=  vp1_clk & vp1_fv & vp1_lv & "XXXXX";

end behaviour;
