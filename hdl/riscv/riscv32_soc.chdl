/* RISC-V simple SoC setup
 *
 * Do not edit this file if it has a .vhdl extension, all changes will be
 * void!
 *
 * DEPRECATED. Use MyHDL approach for generated IP.
 *
 */

#include "../../include/generated/autoconf.h"

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library work;
	use work.busdef.all;
	use work.stdtap.all;
	use work.global_config.all;
	use work.memory_initialization.all;
	use work.system_map.all;
#ifdef CONFIG_RISCV_SECONDARY_TAPREGS
	use work.riscv_tap_ex.all;
#endif
	use work.ram.all;


#ifdef CONFIG_VIRTUAL_RAM
library ghdlex;
	use ghdlex.virtual.all;
#endif


#if defined(CONFIG_RISCV_POTATO)
library potato;
	use potato.potato_pkg.all;
	use potato.pp_types.all;
#endif


#include "../core/common/soc_ports.chdl"

architecture riscv32_top_rtl of SoC is

#include "../core/common/soc_signals.chdl"

#if defined(CONFIG_RISCV_POTATO)
#define SLV std_logic_vector
	signal imem_address : SLV(31 downto 0);
	signal dmem_address	: SLV(31 downto 0);
#else
#define SLV unsigned
#endif

	-- Debugger registers:
	signal tap_secondary_addr : SLV(11 downto 0) := x"7a2";
#ifdef CONFIG_RISCV_SECONDARY_TAPREGS
	signal tap_ctrl   : secondary_tapregs_WritePort;
	signal tap_stat   : secondary_tapregs_ReadPort;
#endif
	signal tap_data_reg      : SLV(31 downto 0);
	-- signal tap_data_mux_out  : SLV(31 downto 0);
	-- signal chipreg_re        : std_ulogic;

 	-- Data memory signals:
	signal dmem_data_in		  : SLV(31 downto 0);
	signal dmem_data_in_mux   : SLV(31 downto 0);
	signal dmem_data_out	  : SLV(31 downto 0);
	signal dmem_data_size	  : SLV( 1 downto 0);
	-- Instruction memory signals:
	signal imem_xs_count   : unsigned(31 downto 0); -- Debugging
	signal imem_data	: SLV(31 downto 0);
	signal imem_req 	: std_ulogic;  -- Instruction memory fetch request
	signal imem_dreq 	: std_ulogic;  -- instruction memory data request
	signal imem_rd  	: std_ulogic;
	-- signal imem_req, imem_ack : std_logic;

	signal imem_data_address : unsigned(CONFIG_ADDR_WIDTH-1 downto 0);

	-- Instantiated DRAM address width:
	constant DRAM_ADDR_WIDTH : natural := CONFIG_DRAM_ADDR_WIDTH;

	signal io_we    : std_logic;
	signal is_mmr   : std_ulogic;
	signal io_re    : std_logic;
	signal io_ready    : std_logic;

#if defined(CONFIG_RISCV_PYRV32)
	signal addr_iomem : unsigned(32-1 downto 0);


	signal io_write_wb : unsigned(WORD_SIZE-1 downto 0);
	signal io_read_wb  : unsigned(WORD_SIZE-1 downto 0);

	signal imem_address : unsigned(CONFIG_ADDR_WIDTH-1 downto 0);
	signal dmem_address	: unsigned(CONFIG_ADDR_WIDTH-1 downto 0);

	signal dmem_data_ready    : std_logic;

#endif
	signal dmem_busy          : std_logic;
	signal dmem_delay         : std_logic;
	-- signal dmem_delay_d       : std_logic;
	signal dmem_read_req	  : std_logic;
	signal dmem_write_req	  : std_ulogic;


	signal l1_data_re		  : std_logic;
	signal l1_data_we		  : std_logic;
	signal l1_data_ready	  : std_logic;
	signal l1_data_out		  : unsigned(31 downto 0);

	-- Peripheral I/O:
	signal perio_read_req	   : std_logic;
	signal perio_read_ack	   : std_logic;
	signal perio_write_req	   : std_logic;
	signal perio_write_ack	   : std_logic;
	signal perio_data_in       : SLV(31 downto 0);

#if defined(CONFIG_RISCV_POTATO)
	-- Wishbone signals:
	signal dmem_if_inputs	: wishbone_master_inputs;
	signal dmem_if_outputs : wishbone_master_outputs;
	signal dmem_read_ack	  : std_logic;
	signal dmem_write_ack	  : std_ulogic;

	signal m1_inputs, m2_inputs   : wishbone_master_inputs;
	signal m1_outputs, m2_outputs : wishbone_master_outputs;

	-- interrupt system --
	signal irq			 : unsigned(7 downto 0) := (others => '0');
	signal irq_ack	 : std_ulogic_vector(03 downto 0);
	signal xirq_sync : std_ulogic_vector(01 downto 0);

#endif

	-- Wishbone interfacing:

	signal wb_perio_wr	  : wb_WritePort;
	signal wb_perio_rd	  : wb_ReadPort;
	signal perio_ce		  : std_ulogic;
	signal perio_ce_d	  : std_ulogic;
	signal perio_mux      : std_ulogic;

	signal wb_slv_adr : std_logic_vector(31 downto 0);
	signal wb_slv_sel : std_logic_vector(3 downto 0);
	signal wb_slv_dat : std_logic_vector(31 downto 0);



	-- Program+data+stack BRAM
	subtype LOW_WORD is integer range 15 downto 0;
	subtype HIGH_WORD is integer range 31 downto 16;

	-- Port A
	signal a_re     : std_logic;
	signal a_we     : std_logic;
	signal a_addr   : ramaddr32_t;
	signal a_write  : unsigned(WORD_SIZE-1 downto 0);
	signal a_read   : unsigned(WORD_SIZE-1 downto 0);
	signal a_read_l : unsigned(WORD_SIZE/2-1 downto 0);
	signal a_read_h : unsigned(WORD_SIZE/2-1 downto 0);
	-- Port B
	signal b_re     : std_logic;
	signal b_we     : std_logic;
	signal b_addr   : ramaddr32_t;
	signal b_write  : unsigned(WORD_SIZE-1 downto 0) := (others => '0');
	signal b_read   : unsigned(WORD_SIZE-1 downto 0);
	signal b_read_l : unsigned(WORD_SIZE/2-1 downto 0);
	signal b_read_h : unsigned(WORD_SIZE/2-1 downto 0);

begin

#if defined(CONFIG_RISCV_POTATO)

	potato_cpu_inst: pp_core
	generic map (
		PROCESSOR_ID => std_logic_vector(CONFIG_TAP_ID)
	)
	port map (
		clk => clk,
		reset => reset,
		timer_clk => clk,
		imem_address => imem_address,
		imem_data_in => imem_data,
		imem_req => open,
		imem_ack => '1',
		dmem_address	 => dmem_address,
		dmem_data_in	 => dmem_data_in_mux,
		dmem_data_out	 => dmem_data_out,
		dmem_data_size	 => dmem_data_size,
		dmem_read_req	 => dmem_read_req,
		dmem_read_ack	 => dmem_read_ack,
		dmem_write_req	 => dmem_write_req,
		dmem_write_ack	 => dmem_write_ack,
		test_context_out => open,
		irq => std_logic_vector(irq)
	);

-- Conversion:
	wb_perio_wr.adr <= unsigned(dmem_if_outputs.adr);
	wb_perio_wr.dat <= unsigned(dmem_if_outputs.dat);
	wb_perio_wr.sel <= unsigned(dmem_if_outputs.sel);
	wb_perio_wr.stb <= dmem_if_outputs.stb;
	wb_perio_wr.cyc <= dmem_if_outputs.cyc;
	wb_perio_wr.we  <= dmem_if_outputs.we;

	dmem_if_inputs.dat <= std_logic_vector(wb_perio_rd.dat);
	dmem_if_inputs.ack <= wb_perio_rd.ack;

	dmem_if: entity potato.pp_wb_adapter
		port map (
			clk			  => clk,
			reset		  => reset,
			mem_address   => dmem_address,
			mem_data_in   => dmem_data_out,
			mem_data_out  => perio_data_in,
			mem_data_size => dmem_data_size,
			mem_read_req  => perio_read_req,
			mem_read_ack  => perio_read_ack,
			mem_write_req => perio_write_req,
			mem_write_ack => perio_write_ack,
			wb_inputs	  => dmem_if_inputs,
			wb_outputs	  => dmem_if_outputs
		);


#elif defined(CONFIG_RISCV_PYRV32)

exec_pulse:
	entity work.flagxdp
	port map (
		reset => tap_reset,
		clki => tin.tapclk,
		datai => tin.emuexec,
		clko => clk,
		datao => strobe
	);

	pyrv32_cpu_inst: entity work.pyrv32_cpu
	port map (
		clk					  => clk,
		reset				  => reset,
		exception_override	  => irq_override,
		exception_irq		  => irq_evt,
		exception_evaddr	  => ivaddr(ivaddr'high downto 0),
		tap_reset			  => tap_reset,
		tap_emumask			  => tin.emumask,
		tap_exstat			  => dbg_exstat,
		tap_idata			  => dbg_emudata_i,
		tap_emuexec			  => strobe,
		tap_addr 			  => tap_secondary_addr,
		tap_odata			  => dbg_emudata_o,
		tap_emuir			  => tin.emuir,
		tap_emuack			  => emuack,
		tap_emurdy			  => emurdy,
		tap_curpc			  => dbg_curpc,
		tap_emureq			  => tin.emurequest,
		dmem_we				  => dmem_write_req,
		dmem_addr			  => dmem_address,
		dmem_delay	          => dmem_delay,
		dmem_busy		      => dmem_busy,
		dmem_ready	          => dmem_data_ready,
		dmem_re				  => dmem_read_req,
		dmem_wsize			  => dmem_data_size,
		dmem_wdata			  => io_write_wb,
		dmem_rdata			  => dmem_data_in_mux,

--		mmr_we        => io_we,
--		mmr_addr      => io_addr32,
--		mmr_re        => io_re,
--		mmr_wdata     => io_write_wb,
--		mmr_rdata     => io_read,
--		mmr_busy      => io_busy,

		imem_write			  => b_we,
		imem_ire     		  => imem_rd,
		imem_idata			  => a_read,
		imem_read			  => b_re,
		imem_daddr			  => imem_data_address,
		imem_wdata			  => b_write,
		imem_rdata			  => b_read,
		imem_iaddr			  => imem_address

	);

// XXX DEBUGGING:
debug_imem_write_access:
	process(clk)
	begin
		if rising_edge(clk) then
			if reset = '1' then
				imem_xs_count <= (others => '0');
			elsif b_we = '1' then
				imem_xs_count <= imem_xs_count + 1;
			end if;
		end if;
	end process;

	-- Ready signal, when core is in DELAY mode:
	dmem_data_ready <= io_ready or l1_data_ready;

	tout.count <= imem_xs_count;

	tout.emuack <= emuack;
	tout.emurdy <= emurdy;
	tout.emudata <= dbg_emudata_o;
	dbg_emudata_i <= tin.emudata;
	tout.dbgpc <= dbg_curpc;
	-- tout.count <= x"0000" & std_logic_vector(exec_count);
	tout.exstat <= dbg_exstat;
	tout.break <= '0'; -- no break bit exported to TAP

	imem_req <= imem_rd;
	imem_dreq <= b_re or b_we;

	------------------------------------------------
	-- Wishbone bridge:

bus_bridge:
	entity work.wb2pyps
	port map (
		clk			=> clk,
		addr		=> addr_iomem,
		we			=> io_we,
		re			=> io_re,
		sz   		=> dmem_data_size,
		din			=> io_write_wb,
		dout		=> io_read_wb,
		wb_in		=> wb_perio_rd,
		wb_out		=> wb_perio_wr,
		reset		=> reset
	);

	perio_data_in <= io_read_wb;
	io_we <= dmem_write_req when perio_ce = '1' else '0';
	io_re <= dmem_read_req when perio_ce  = '1' else '0';
	addr_iomem <= resize(dmem_address, 32);

	dmem_data_out <= io_write_wb;

	-- We are busy when we access MMR:
	dmem_busy <= io_re;

#endif

	dmem_data_in_mux <= dmem_data_in when perio_mux = '0' or l1_data_ready = '1'
		else perio_data_in;

--	wb_perio_rd.sel <= (others => '0');
--	wb_perio_rd.dat <= (others => '0');
--	wb_perio_rd.ack <= '0';
--	wb_perio_rd.inta <= '0';

	-- L1 data is always ready:

#if defined(CONFIG_RISCV_POTATO)
	dmem_read_ack <= perio_read_ack when perio_ce_d = '1' else '1';
	dmem_write_ack <= perio_write_ack when perio_ce_d = '1' else '1';
#else
	perio_read_ack <= wb_perio_rd.ack;
	perio_write_ack <= wb_perio_rd.ack;
#endif
		
	perio_read_req <= dmem_read_req when is_mmr = '1' else '0';
	perio_write_req <= dmem_write_req when is_mmr = '1' else '0';

	perio_ce <= perio_read_req or perio_write_req;

----------------------------------------------------------------------------
-- RAM/ROM arena

	a_addr <= unsigned(imem_address(CONFIG_BRAM_ADDR_WIDTH-1 downto BYTE_BITS));
	-- Note: this can be multiplexed with prefetch/branch prediction
	-- auxiliaries in some setups
	b_addr <= unsigned(imem_data_address(CONFIG_BRAM_ADDR_WIDTH-1 downto BYTE_BITS));
	imem_data <= SLV(a_read);


#ifdef CONFIG_VIRTUAL_RAM


vram_l: VirtualDualPortRAM_ce
	generic map (
		NETPP_NAME => "VRAM_L",
		ADDR_W => CONFIG_BRAM_ADDR_WIDTH-2,
		DATA_W => 16,
		INIT_DATA => to_vram32_init(vram16_init_t(BOOTROM_PROG_INIT(0)))
	)
	port map (
		clk       => clk,
		a_ce      => imem_req,
		a_we      => a_we,
		a_addr    => a_addr,
		a_write   => a_write(LOW_WORD),
		a_read    => a_read(LOW_WORD),
		b_ce      => imem_dreq,
		b_we      => b_we,
		b_addr    => b_addr,
		b_write   => b_write(LOW_WORD),
		b_read    => b_read(LOW_WORD)
	);


vram_h: VirtualDualPortRAM_ce
	generic map (
		NETPP_NAME => "VRAM_H",
		ADDR_W => CONFIG_BRAM_ADDR_WIDTH-2,
		DATA_W => 16,
		INIT_DATA => to_vram32_init(vram16_init_t(BOOTROM_PROG_INIT(1)))
	)
	port map (
		clk       => clk,
		a_ce      => imem_req,
		a_we      => a_we,
		a_addr    => a_addr,
		a_write   => a_write(HIGH_WORD),
		a_read    => a_read(HIGH_WORD),
		b_ce      => imem_dreq,
		b_we      => b_we,
		b_addr    => b_addr,
		b_write   => b_write(HIGH_WORD),
		b_read    => b_read(HIGH_WORD)
	);

#else

#ifdef CONFIG_GHDL_SYNTH

	a_write <= (others => '0');

#if 0

	a_read <= (others => '0');
	b_read <= (others => '0');

#else

	a_read <= a_read_h & a_read_l;
	b_read <= b_read_h & b_read_l;

rom_l: DPRAM16_init_hex_ce
	generic map (
		ADDR_W => CONFIG_BRAM_ADDR_WIDTH-2, -- 32 bit wide, LSB 0 aligned
		INIT_DATA => "bootrom_l.hex"
	)
	port map (
		a_clk	  => clk,
		a_ce      => imem_req,
		a_we	  => a_we,
		a_addr	  => a_addr,
		a_write   => a_write(LOW_WORD),
		a_read	  => a_read_l,
		--
		b_clk     => clk,
		b_ce	  => imem_dreq,
		b_we	  => b_we,
		b_addr	  => b_addr,
		b_write   => b_write(LOW_WORD),
		b_read	  => b_read_l
	);



rom_h: DPRAM16_init_hex_ce
	generic map (
		ADDR_W => CONFIG_BRAM_ADDR_WIDTH-2, -- 32 bit wide, LSB 0 aligned
		INIT_DATA => "bootrom_h.hex"
	)
	port map (
		a_clk	  => clk,
		a_ce	  => imem_req,
		a_we	  => a_we,
		a_addr	  => a_addr,
		a_write   => a_write(HIGH_WORD),
		a_read	  => a_read_h,
		--
		b_clk	  => clk,
		b_ce	  => imem_dreq,
		b_we	  => b_we,
		b_addr	  => b_addr,
		b_write   => b_write(HIGH_WORD),
		b_read	  => b_read_h
	);


#endif

#else

rom_l: DPRAM16_init_ce
	generic map (
		ADDR_W => CONFIG_BRAM_ADDR_WIDTH-2, -- 32 bit wide, LSB 0 aligned
		INIT_DATA => ram16_init_t(BOOTROM_PROG_INIT(0))
	)
	port map (
		clk		  => clk,
		a_ce      => imem_req,
		a_we	  => a_we,
		a_addr	  => a_addr,
		a_write   => a_write(LOW_WORD),
		a_read	  => a_read(LOW_WORD),
		--
		b_ce	  => imem_dreq,
		b_we	  => b_we,
		b_addr	  => b_addr,
		b_write   => b_write(LOW_WORD),
		b_read	  => b_read(LOW_WORD)
	);

rom_h: DPRAM16_init_ce
	generic map (
		ADDR_W => CONFIG_BRAM_ADDR_WIDTH-2, -- 32 bit wide, LSB 0 aligned
		INIT_DATA => ram16_init_t(BOOTROM_PROG_INIT(1))
	)
	port map (
		clk		  => clk,
		a_ce	  => imem_req,
		a_we	  => a_we,
		a_addr	  => a_addr,
		a_write   => a_write(HIGH_WORD),
		a_read	  => a_read(HIGH_WORD),
		--
		b_ce	  => imem_dreq,
		b_we	  => b_we,
		b_addr	  => b_addr,
		b_write   => b_write(HIGH_WORD),
		b_read	  => b_read(HIGH_WORD)
	);

#endif
#endif // VIRTUAL_RAM

data_memory_bank_a:
	entity work.lb_dma_memory
	generic map (
		LB_ADDR_W => DRAM_ADDR_WIDTH
	)
	port map (
		clk             => clk,
		delay			=> dmem_delay,
		ready     		=> l1_data_ready,
		lb_re			=> l1_data_re,
		lb_we			=> l1_data_we,
		lb_size_select	=> unsigned(dmem_data_size),
		lb_addr			=> unsigned(dmem_address(DRAM_ADDR_WIDTH-1 downto 0)),
		lb_data_in		=> unsigned(dmem_data_out),
		lb_data_out		=> l1_data_out,

		dma_mode		=> "00",
		dma_addr		=> (others => '0'),
		dma_datain		=> (others => '0'),
		dma_dataout		=> open,
		dma_we			=> '0'

	);

	l1_data_re <= dmem_read_req and not perio_ce;
	l1_data_we <= dmem_write_req and not perio_ce;
	dmem_data_in <= SLV(l1_data_out);

----------------------------------------------------------------------------
#ifdef CONFIG_MAC
#include "../core/common/mac.chdl"
#endif

#include "../core/common/soc_body.chdl"

#include "../core/common/perio.chdl"

perio_select_delay:
	process(clk)
	begin
		if rising_edge(clk) then
			perio_ce_d <= perio_ce and io_re;
			perio_mux <= perio_ce_d;
			-- MMR is always ready after one wait cycle:
			io_ready <= perio_read_ack;
		end if;
	end process;

	is_mmr <= dmem_address(CONFIG_MMR_ADDR_BIT);


#if defined(CONFIG_RISCV_POTATO)
external_irq_sync: process(clk)
	begin
		if rising_edge(clk) then
			xirq_sync <= xirq_sync(0) & irq0;
		end if;
	end process external_irq_sync;
#endif


#ifndef HAVE_UART_IOMUX_SEL
		uart_iosel <= '0';
#endif



#if defined(SOC_EMIL)
		-- interrupt priority assignment --
		irq_input(B_PINMAP_IRQ_TIMER0) <= pwm_irq(0);
		irq_input(B_PINMAP_IRQ_IO)	 <= '0';
		irq_input(BV_PINMAP_IRQ_DMA)	 <= dma_irq;
#elif defined(SOC_BEATRIX)
		irq_input(B_PINMAP_IRQ_TIMER0) <= pwm_irq(0);
#endif

-- emudata_mux_reg_select:
-- 	entity work.decode_secondary_tapregs
-- 	generic map (DATA_WIDTH => 32)
-- 	port map (
-- 		ce       => '1',
-- 		ctrl     => tap_ctrl,
-- 		stat     => tap_stat,
-- 		data_in  => tap_data_reg,
-- 		data_out => tap_data_mux_out,
-- 		addr     => tin.craddr,
-- 		re       => chipreg_re,
-- 		we       => tin.emuexec,
-- 		clk      => clk
-- 	);
-- 
-- select_chipreg:
-- 	process(clk)
-- 	begin
-- 		if rising_edge(clk) then
-- 
-- 		end if;
-- 	end process;

end riscv32_top_rtl;
