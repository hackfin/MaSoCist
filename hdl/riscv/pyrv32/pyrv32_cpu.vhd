-- File: pyrv32_cpu.vhd
-- Generated by MyHDL 0.11
-- Date: Mon Oct 28 21:27:06 2019


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_011.all;

entity pyrv32_cpu is
    port (
        clk: in std_logic;
        reset: in std_logic;
        exception_override: in std_logic;
        exception_irq: in std_logic;
        exception_evaddr: in unsigned(14 downto 0);
        exception_illegal: out std_logic;
        tap_reset: in std_logic;
        tap_emumask: in std_logic;
        tap_exstat: out unsigned(7 downto 0);
        tap_idata: in unsigned(31 downto 0);
        tap_addr: in unsigned(11 downto 0);
        tap_emuexec: in std_logic;
        tap_odata: out unsigned(31 downto 0);
        tap_emuir: in unsigned(31 downto 0);
        tap_emuack: out std_logic;
        tap_emurdy: out std_logic;
        tap_curpc: out unsigned(31 downto 0);
        tap_emureq: in std_logic;
        dmem_we: out std_logic;
        dmem_busy: in std_logic;
        dmem_addr: out unsigned(19 downto 0);
        dmem_re: out std_logic;
        dmem_ready: in std_logic;
        dmem_delay: out std_logic;
        dmem_wsize: out unsigned(1 downto 0);
        dmem_wdata: out unsigned(31 downto 0);
        dmem_rdata: in unsigned(31 downto 0);
        imem_write: out std_logic;
        imem_idata: in unsigned(31 downto 0);
        imem_read: out std_logic;
        imem_daddr: out unsigned(19 downto 0);
        imem_wdata: out unsigned(31 downto 0);
        imem_rdata: in unsigned(31 downto 0);
        imem_iaddr: out unsigned(19 downto 0);
        imem_ire: out std_logic
    );
end entity pyrv32_cpu;
-- The pyrv32 - a simplified 32 bit RiscV
-- 
-- This is a RISC-V RV32I compatible derivative of the configurable
-- PyPS architecture (written in Python/MyHDL)
-- 
-- (c) 2014-2019, info@section5.ch
-- 
--     CHANGES:
--  *  2016       MIPS dropped
--  *  2019       added support for RV32I/C instruction set
-- 
-- This architecture is not completely verified or considered frozen.
-- However, it has passed all (except fence_i) rv32ui ISA tests
-- from the riscv-tests suite https://github.com/riscv/riscv-tests
-- (as of October 2019)
-- 
-- You may use and evaluate it under the MaSoCist license:
--   https://github.com/hackfin/masocist
-- 
-- Configuration notes:
-- 
-- - When CONFIG_RV32_CSR not enabled, debug ICE is limited and must operate
--   via memory mapped registers to communicate with external debug logic.
-- - IRQs are treated the same as exceptions, unless CONFIG_SCACHE option
--   is enabled
-- - When a CSR is implemented, exception support and event vectoring will go
--   through this CSR. By default, we don't use the CSR logic and use
--   the ZPUng SIC (CONFIG_SIC=True).
-- 
--   NOTE! The pyrv32 does not support nested interrupts in hardware. Interrupt
--   handlers must explicitely allow nesting by unlocking the IRQ logic (evt_override)
-- 
-- ############################################
-- ##########     CONFIGURATION     ###########
-- ############################################
-- CONFIG_ALLOW_IMEM_ACCESS = True
-- CONFIG_DEBUG_ICE = True
-- CONFIG_RISCV_PYRV32 = True
-- CONFIG_PYRV32_VARIANT = 1
-- CONFIG_FOUR_STAGE_PIPELINE = True
-- CONFIG_RV32_CSR = True
-- CONFIG_SIC = True
-- CONFIG_RISCV_ARCH = True
-- CONFIG_ALLOW_IMEM_WRITE = True
-- CONFIG_EARLY_BRANCH_DETECTION = True
-- ############################################
-- >  DISABLED:
-- ############################################
--     CONFIG_READ_DELAY
--     CONFIG_BRANCH_PREDICTION_DP
--     CONFIG_RELAXED_LSB
--     CONFIG_SUPERVISOR_INSTRUCTIONS
--     CONFIG_COMPRESSED_INSTRUCTIONS
--     CONFIG_FLIX_INSTRUCTIONS
--     CONFIG_LATE_MEMBUSY
--     CONFIG_SCACHE
--     CONFIG_COTTONPICKEN
-- ############################################

architecture MyHDL of pyrv32_cpu is


subtype SLICE_IMML_S is integer range 12-1 downto 7;
subtype FUNCT12 is integer range 32-1 downto 20;
subtype FUNCT3 is integer range 15-1 downto 12;
subtype OPCODE is integer range 7-1 downto 0;
subtype SLICE_RS1 is integer range 20-1 downto 15;
subtype SLICE_RS2 is integer range 25-1 downto 20;


type t_enum_dbg_state_4 is (
	S_RUN,
	S_RESUME,
	S_EMUACK,
	S_EMULATION,
	S_EMUEXEC
	);
type t_enum_t_aluop_3 is (
	A_NOP,
	A_ADD,
	A_SUB,
	A_SRL,
	A_SRA,
	A_SLL,
	A_SLT,
	A_SLTU,
	A_XOR,
	A_OR,
	A_AND
	);
type t_enum_t_itype_5 is (
	TYPE_NONE,
	TYPE_R,
	TYPE_I,
	TYPE_B,
	TYPE_S,
	TYPE_U,
	TYPE_J
	);
type t_enum_t_lmode_6 is (
	LB,
	LH,
	LW,
	LBU,
	LHU
	);
type t_enum_t_mode_2 is (
	NOP,
	JMP,
	COND_BRANCH,
	LOAD,
	STORE,
	IMMEDIATE,
	ALU,
	CONTROL,
	EXTEND,
	ILLEGAL,
	xRET,
	RETE,
	SWTRAP,
	IDLE,
	CP_XCH,
	CP_SET,
	CP_CLR
	);
type t_enum_t_state_1 is (
	S_RESET,
	S_IDLE,
	S_EXEC,
	S_DELAY,
	S_EVT,
	S_EVT_DELAY,
	S_IRQ,
	S_IRQ_DELAY,
	S_HOLD,
	S_WAIT,
	S_HOLD_DELAY,
	S_RESUME,
	S_BRANCH_SYNC,
	S_BRANCH_DELAY
	-- S_EXC
	);

signal evt_brk: std_logic;
signal regd_we: std_logic;
signal action_reg_we: std_logic;
signal action_upie: std_logic;
signal evt_exception: std_logic;
signal trigger_hold: std_logic;
signal evt_data_valid: std_logic;
signal imm: unsigned(31 downto 0);
signal haz_access_future: std_logic;
signal action_emuexec: std_logic;
signal haz_s2bypass: std_logic;
signal curpc: unsigned(14 downto 0);
signal branch: std_logic;
signal haz_load_collision: std_logic;
signal evt_idle: std_logic;
signal pipe_clr: std_logic;
signal de_en: std_logic;
signal s2_haz: std_logic;
signal evt_dbg_wr: std_logic;
signal lhold: std_logic;
signal action_dbg_wr: std_logic;
signal ex_en: std_logic;
signal action_saveret: std_logic;
signal mode: t_enum_t_mode_2;
signal ibranch: std_logic;
signal newpc: unsigned(14 downto 0);
signal evt_membusy: std_logic;
signal haz_s2bypass_delayed: std_logic;
signal haz_s1bypass_delayed: std_logic;
signal action_wreg: std_logic;
signal reg_d: unsigned(4 downto 0);
signal irqack: std_logic;
signal evt_irq: std_logic;
signal state: t_enum_t_state_1;
signal haz_s1bypass: std_logic;
signal evt_busy: std_logic;
signal did_stall: std_logic;
signal evt_cpustat: unsigned(7 downto 0);
signal reg_s2: unsigned(4 downto 0);
signal reg_s1: unsigned(4 downto 0);
signal evt_override: std_logic;
signal rdata_d: unsigned(31 downto 0);
signal action_branch: std_logic;
signal regd_addr: unsigned(4 downto 0);
signal action_rete: std_logic;
signal irqlatch0: std_logic;
signal func: unsigned(2 downto 0);
signal evt_stall: std_logic;
signal depc: unsigned(14 downto 0);
signal evt_emuack: std_logic;
signal expc: unsigned(14 downto 0);
signal evt_saveret: std_logic;
signal irqprio: std_logic;
signal pipe_en: std_logic;
signal regd_data: unsigned(31 downto 0);
signal evt_vector: unsigned(14 downto 0);
signal evt_reset: std_logic;
signal maybe_bypass_s1: std_logic;
signal fe_en: std_logic;
signal evt_dbgbreak: std_logic;
signal evt_emuexec: std_logic;
signal action_delay: std_logic;
signal evt_hold: std_logic;
signal insn: unsigned(31 downto 0);
signal evt_rete: std_logic;
signal evt_reti: std_logic;
signal s1_haz: std_logic;
signal action_preload: std_logic;
signal pipe_valid: unsigned(3 downto 0);
signal lwait: std_logic;
signal sh: unsigned(4 downto 0);
signal evt_emumask: std_logic;
signal regbank_tri0_data_s: unsigned(31 downto 0);
signal regbank_tri0_data_t: unsigned(31 downto 0);
signal execute0_mem_store_data: unsigned(31 downto 0);
signal execute0_regd_buf: unsigned(31 downto 0);
signal execute0_reg_out: unsigned(31 downto 0);
signal execute0_mux_sh: unsigned(4 downto 0);
signal execute0_regs1_buf: unsigned(31 downto 0);
signal execute0_result: unsigned(31 downto 0);
signal execute0_indirect: unsigned(31 downto 0);
signal execute0_rs1: unsigned(31 downto 0);
signal execute0_rs2: unsigned(31 downto 0);
signal execute0_jump_target: unsigned(31 downto 0);
signal execute0_reg_we_d: std_logic;
signal execute0_reg_we: std_logic;
signal execute0_will_branch: std_logic;
signal execute0_action_store: std_logic;
signal execute0_action_swbrk: std_logic;
signal execute0_mem_load_data: unsigned(31 downto 0);
signal execute0_s1bypass_d: std_logic;
signal execute0_did_stall: std_logic;
signal execute0_s1bypass: std_logic;
signal execute0_branch: std_logic;
signal execute0_s2bypass: std_logic;
signal execute0_alu_en: std_logic;
signal execute0_action_load: std_logic;
signal execute0_mux_b: unsigned(31 downto 0);
signal execute0_mem_addr: unsigned(31 downto 0);
signal execute0_mux_a: unsigned(31 downto 0);
signal execute0_csr_xs: std_logic;
signal execute0_mepc: unsigned(14 downto 0);
signal execute0_action_srcpc: std_logic;
signal execute0_s2bypass_d: std_logic;
signal execute0_csrreg_depc: unsigned(31 downto 0);
signal execute0_regs2_buf: unsigned(31 downto 0);
signal execute0_csrreg_mepc: unsigned(31 downto 0);
signal execute0_action_immediate: std_logic;
signal execute0_reg_in: unsigned(31 downto 0);
signal execute0_did_load: std_logic;
signal execute0_alu0_alu_mode: t_enum_t_aluop_3;
signal execute0_csr0_csr_we: std_logic;
signal execute0_csr0_csrreg_mcause: unsigned(31 downto 0);
signal execute0_csr0_illegal_csr: std_logic;
signal execute0_csr0_csr_addr: unsigned(11 downto 0);
signal execute0_csr0_reg: unsigned(31 downto 0);
signal execute0_csr0_csrreg_misa: unsigned(31 downto 0);
signal execute0_csr0_data: unsigned(31 downto 0);
signal execute0_csr0_csrreg_dscratch0: unsigned(31 downto 0);
signal execute0_csr0_csrreg_mstatus: unsigned(31 downto 0);
signal execute0_csr0_csrreg_mtvec: unsigned(31 downto 0);
signal execute0_csr0_csr_re: std_logic;
signal execute0_csr0_csrreg_mie: unsigned(31 downto 0);
signal debug_logic0_swbreak: std_logic;
signal debug_logic0_busy: std_logic;
signal debug_logic0_state: t_enum_dbg_state_4;
signal debug_logic0_emumask: std_logic;
signal decode0_de_action_swbrk: std_logic;
signal decode0_de_action_srcpc: std_logic;
signal decode0_de_action_immediate: std_logic;
signal decode0_pc_mode: t_enum_t_mode_2;
signal decode0_pc_func: unsigned(5 downto 0);
signal decode0_de_action_wreg: std_logic;
signal decode0_de_action_aop: t_enum_t_aluop_3;
signal decode0_action_lmode: t_enum_t_lmode_6;
signal decode0_de_action_lmode: t_enum_t_lmode_6;
signal decode0_pc_imm: unsigned(31 downto 0);
signal decode0_instruction_decode0_imm31: std_logic;
signal decode0_instruction_decode0_immtype: t_enum_t_itype_5;
signal decode0_instruction_decode0_imm_extend_21: unsigned(20 downto 0);
signal fetch0_nextpc: unsigned(31 downto 0);
signal fetch0_pc: unsigned(31 downto 0);
signal memio_mode_d: t_enum_t_lmode_6;
signal memio_was_imem: std_logic;
signal memio_data_mux: unsigned(31 downto 0);
signal memio_is_imem: std_logic;
signal memio_dmem_busy_d: std_logic;
type t_array_was_membusy is array(0 to 2-1) of std_logic;
signal was_membusy: t_array_was_membusy;
type t_array_was_delay is array(0 to 2-1) of std_logic;
signal was_delay: t_array_was_delay;
type t_array_regd_d is array(0 to 2-1) of unsigned(4 downto 0);
signal regd_d: t_array_regd_d;
type t_array_regbank_tri0_regt is array(0 to 31-1) of unsigned(31 downto 0);
signal regbank_tri0_regt: t_array_regbank_tri0_regt;
type t_array_regbank_tri0_regs is array(0 to 31-1) of unsigned(31 downto 0);
signal regbank_tri0_regs: t_array_regbank_tri0_regs;

function MYHDL39_UNDEFINED(
    x: in natural
    ) return unsigned is
begin
    return unsigned'("00000000000000000000000000000000");
end function MYHDL39_UNDEFINED;

begin



decode0_instruction_decode0_imm_extend_21(20) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(19) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(18) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(17) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(16) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(15) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(14) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(13) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(12) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(11) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(10) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(9) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(8) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(7) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(6) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(5) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(4) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(3) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(2) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(1) <= decode0_instruction_decode0_imm31;
decode0_instruction_decode0_imm_extend_21(0) <= decode0_instruction_decode0_imm31;

-- * Hazard 3: when in delayed writeback (S_DELAY state)
--   and a result is needed *two* cycles later:
--   > Forward value
-- 
-- This is a nasty one. PyPS throws an exception when writing reg 0,
-- Risc-V does not. So we don't have a hazard when we were just
-- dummy-writing to 0.
PYRV32_CPU_HAZ_DELAYED_WB: process (state, regd_d(1), reg_s1, reg_s2, did_stall) is
begin
    haz_s1bypass_delayed <= '0';
    haz_s2bypass_delayed <= '0';
    if ((state = S_DELAY) and (did_stall = '0') and (regd_d(1) /= 0)) then
        if (regd_d(1) = reg_s1) then
            haz_s1bypass_delayed <= '1';
        end if;
        if (regd_d(1) = reg_s2) then
            haz_s2bypass_delayed <= '1';
        end if;
    end if;
end process PYRV32_CPU_HAZ_DELAYED_WB;

PYRV32_CPU_REGBANK_TRI0_WORK: process (clk) is
begin
    if rising_edge(clk) then
        if (regd_we = '1') then
            if (regd_addr /= 0) then
                
                regbank_tri0_regs(to_integer(unsigned(resize(regd_addr, 6)) - 1)) <= regd_data;
                regbank_tri0_regt(to_integer(unsigned(resize(regd_addr, 6)) - 1)) <= regd_data;
            else
                
            end if;
        end if;
        if (de_en = '1') then
            if (reg_s1 = 0) then
                regbank_tri0_data_s <= to_unsigned(0, 32);
            elsif ((reg_s1 = regd_addr) and (regd_we = '1')) then
                regbank_tri0_data_s <= regd_data;
            else
                regbank_tri0_data_s <= regbank_tri0_regs(to_integer(unsigned(resize(reg_s1, 6)) - 1));
            end if;
            if (reg_s2 = 0) then
                regbank_tri0_data_t <= to_unsigned(0, 32);
            elsif ((reg_s2 = regd_addr) and (regd_we = '1')) then
                regbank_tri0_data_t <= regd_data;
            else
                regbank_tri0_data_t <= regbank_tri0_regs(to_integer(unsigned(resize(reg_s2, 6)) - 1));
            end if;
        end if;
    end if;
end process PYRV32_CPU_REGBANK_TRI0_WORK;

PYRV32_CPU_HAZ_LOAD_COLL: process (lwait, action_preload, action_delay, evt_membusy) is
begin
    if ((bool(action_preload) and (not bool(evt_membusy))) and bool(lwait) and bool(action_delay)) then
        haz_load_collision <= '1';
    else
        haz_load_collision <= '0';
    end if;
end process PYRV32_CPU_HAZ_LOAD_COLL;

PYRV32_CPU_HANDLE_MEMORY_DELAY_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        lwait <= stdl(bool(action_preload) and bool(evt_membusy));
        did_stall <= evt_stall;
        if (lhold = '0') then
            if (haz_load_collision = '1') then
                lhold <= '1';
            end if;
        else
            if (action_preload = '0') then
                lhold <= '0';
            end if;
        end if;
    end if;
end process PYRV32_CPU_HANDLE_MEMORY_DELAY_LOGIC;

-- Common assignments
PYRV32_CPU_COMMON: process (irqack, dmem_ready, action_emuexec, evt_dbgbreak, evt_idle, state, branch, evt_hold, action_rete, imem_idata, irqlatch0, evt_brk, dmem_busy, evt_dbg_wr, reset, evt_stall, tap_emuir, lhold, pipe_valid, exception_irq, exception_override, mode, evt_emuack, exception_evaddr, evt_saveret) is
    variable busy: std_logic;
    variable fetch_enable: std_logic;
    variable is_branch: std_logic;
    variable is_exception: std_logic;
    variable flush: std_logic;
    variable is_stall: std_logic;
    variable execute_enable: std_logic;
begin
    evt_emumask <= '0';
    evt_reset <= reset;
    evt_irq <= exception_irq;
    evt_override <= exception_override;
    evt_vector <= exception_evaddr;
    evt_rete <= action_rete;
    evt_membusy <= dmem_busy;
    evt_data_valid <= dmem_ready;
    flush := stdl((state = S_IDLE) or (state = S_HOLD) or (state = S_HOLD_DELAY) or (state = S_WAIT));
    is_exception := stdl((state = S_EVT) or (state = S_EVT_DELAY));
    evt_exception <= is_exception;
    action_dbg_wr <= evt_dbg_wr;
    action_delay <= stdl((state = S_DELAY) or (state = S_BRANCH_DELAY) or (state = S_HOLD_DELAY) or (state = S_WAIT) or (state = S_EVT_DELAY) or (state = S_IRQ_DELAY));
    trigger_hold <= stdl(bool(evt_hold) or bool(evt_brk));
    dmem_delay <= lhold;
    is_branch := stdl(bool(branch) or bool(is_exception));
    ibranch <= is_branch;
    busy := stdl(pipe_valid((4 - 1)-1 downto 0) /= 0);
    evt_busy <= busy;
    evt_cpustat <= unsigned'(evt_idle & evt_dbgbreak & irqack & irqlatch0 & evt_brk & evt_saveret & busy & reset);
    pipe_en <= stdl((not bool(evt_emuack)) and (not bool(flush)));
    is_stall := evt_stall;
    pipe_clr <= stdl(bool(evt_idle) or bool(evt_brk));
    fetch_enable := stdl((bool(is_branch) or bool(pipe_valid(0))) and (not bool(is_stall)));
    fe_en <= fetch_enable;
    imem_ire <= fetch_enable;
    de_en <= stdl(bool(pipe_valid(1)) and (not bool(is_stall)));
    execute_enable := pipe_valid(2);
    ex_en <= stdl(bool(execute_enable) and (not bool(is_stall)));
    exception_illegal <= stdl((mode = ILLEGAL) and bool(execute_enable));
    if (mode = STORE) then
        maybe_bypass_s1 <= '0';
    else
        maybe_bypass_s1 <= '1';
    end if;
    if bool(action_emuexec) then
        insn <= tap_emuir;
    else
        insn <= imem_idata;
    end if;
end process PYRV32_CPU_COMMON;

-- Complex state machine using DELAY/shortcut pipeline implementation
-- Handles CPU state and program flow.
-- TODO: Simplify, use separate delay state.
PYRV32_CPU_STATE_WORKER: process (clk) is
begin
    if rising_edge(clk) then
        action_emuexec <= evt_emuexec;
        evt_saveret <= '0';
        case state is
            when S_RESET =>
                state <= S_EXEC;
            when S_EXEC =>
                if (trigger_hold = '1') then
                    if bool(evt_membusy) then
                        state <= S_WAIT;
                    elsif (not bool(evt_busy)) then
                        state <= S_HOLD;
                    end if;
                elsif (action_branch = '1') then
                    state <= S_BRANCH_SYNC;
                elsif (bool(irqlatch0) and bool(de_en) and (not bool(evt_emuack))) then
                    evt_saveret <= '1';
                    if bool(evt_membusy) then
                        state <= S_EVT_DELAY;
                    else
                        state <= S_EVT;
                    end if;
                elsif (evt_idle = '1') then
                    evt_saveret <= '1';
                    state <= S_IDLE;
                elsif bool(evt_membusy) then
                    state <= S_DELAY;
                end if;
            when S_DELAY =>
                if (trigger_hold = '1') then
                    if bool(evt_membusy) then
                        state <= S_WAIT;
                    elsif (not bool(evt_busy)) then
                        state <= S_HOLD_DELAY;
                    end if;
                elsif (action_branch = '1') then
                    state <= S_BRANCH_DELAY;
                elsif (bool(irqlatch0) and bool(de_en) and (not bool(evt_emuack))) then
                    state <= S_EVT_DELAY;
                    evt_saveret <= '1';
                elsif (evt_idle = '1') then
                    evt_saveret <= '1';
                    state <= S_IDLE;
                end if;
            when S_WAIT =>
                if (evt_data_valid = '1') then
                    state <= S_HOLD_DELAY;
                end if;
            when S_HOLD_DELAY =>
                if (evt_hold = '0') then
                    state <= S_RESUME;
                end if;
            when S_BRANCH_SYNC =>
                if (trigger_hold = '1') then
                    state <= S_HOLD;
                elsif (evt_idle = '1') then
                    state <= S_IDLE;
                elsif (bool(irqlatch0) and (not bool(irqack))) then
                    evt_saveret <= '1';
                    state <= S_EVT;
                elsif (de_en = '1') then
                    state <= S_EXEC;
                end if;
            when S_BRANCH_DELAY =>
                if (trigger_hold = '1') then
                    state <= S_HOLD_DELAY;
                elsif (evt_idle = '1') then
                    state <= S_IDLE;
                elsif (bool(irqlatch0) and (not bool(irqack))) then
                    state <= S_EVT_DELAY;
                    evt_saveret <= '1';
                elsif (de_en = '1') then
                    state <= S_EXEC;
                end if;
            when S_HOLD =>
                if (evt_hold = '0') then
                    state <= S_RESUME;
                end if;
            when S_RESUME =>
                state <= S_EXEC;
            when S_EVT =>
                if (branch = '1') then
                    state <= S_BRANCH_SYNC;
                elsif (not bool(evt_stall)) then
                    if (evt_membusy = '1') then
                        state <= S_IRQ_DELAY;
                    else
                        state <= S_IRQ;
                    end if;
                end if;
            when S_EVT_DELAY =>
                if (branch = '1') then
                    state <= S_BRANCH_DELAY;
                elsif (not bool(evt_stall)) then
                    state <= S_IRQ_DELAY;
                end if;
            when S_IRQ =>
                state <= S_BRANCH_SYNC;
            when S_IRQ_DELAY =>
                state <= S_BRANCH_DELAY;
            when S_IDLE =>
                if (evt_irq = '1') then
                    state <= S_IRQ;
                end if;
        end case;
    end if;
end process PYRV32_CPU_STATE_WORKER;

-- * Hazard 2: access of a register value that should have been
--   loaded from memory in the previous cycle:
--   > Stall pipeline
PYRV32_CPU_HAZ_ACCESS: process (haz_s1bypass, haz_s2bypass, action_preload, evt_membusy) is
begin
    if (bool(action_preload) and (bool(haz_s1bypass) or bool(haz_s2bypass))) then
        haz_access_future <= evt_membusy;
    else
        haz_access_future <= '0';
    end if;
end process PYRV32_CPU_HAZ_ACCESS;


evt_reti <= stdl(bool(ex_en) and (mode = xRET));

-- Logic to issue a 'preload' action. When a MMR CSR is implemented,
-- CSR command accesses trigger preload events as well
PYRV32_CPU_EXECUTE0_PRELOAD_ASSERT: process (ex_en, mode) is
    variable is_csr_mmr: std_logic;
begin
    is_csr_mmr := '0';
    if bool(ex_en) then
        case mode is
            when STORE =>
                execute0_action_store <= '1';
                action_preload <= '0';
            when LOAD =>
                execute0_action_store <= '0';
                action_preload <= '1';
            when CP_XCH =>
                execute0_action_store <= is_csr_mmr;
                action_preload <= is_csr_mmr;
            when CP_SET =>
                execute0_action_store <= is_csr_mmr;
                action_preload <= is_csr_mmr;
            when CP_CLR =>
                execute0_action_store <= is_csr_mmr;
                action_preload <= is_csr_mmr;
            when others =>
                execute0_action_store <= '0';
                action_preload <= '0';
        end case;
    else
        execute0_action_store <= '0';
        action_preload <= '0';
    end if;
end process PYRV32_CPU_EXECUTE0_PRELOAD_ASSERT;


execute0_mem_addr <= execute0_indirect;
execute0_mem_store_data <= execute0_rs2;

-- Instruction executing
PYRV32_CPU_EXECUTE0_INSN_EXEC: process (clk) is
    variable rwe: std_logic;
begin
    if rising_edge(clk) then
        action_rete <= '0';
        execute0_branch <= execute0_will_branch;
        execute0_csr_xs <= '0';
        execute0_s1bypass_d <= haz_s1bypass_delayed;
        execute0_s2bypass_d <= haz_s2bypass_delayed;
        execute0_reg_we_d <= execute0_reg_we;
        if bool(ex_en) then
            rwe := '0';
            if (mode = ALU) then
                rwe := '1';
            elsif (mode = IMMEDIATE) then
                rwe := '1';
            elsif (mode = LOAD) then
                rwe := '1';
            elsif (mode = CP_XCH) then
                rwe := '1';
                execute0_csr_xs <= '1';
            elsif (mode = CP_SET) then
                rwe := '1';
                execute0_csr_xs <= '1';
            elsif (mode = CP_CLR) then
                rwe := '1';
                execute0_csr_xs <= '1';
            elsif (mode = JMP) then
                rwe := '1';
            elsif (mode = RETE) then
                action_rete <= '1';
            end if;
            execute0_reg_we <= rwe;
        else
            execute0_reg_we <= '0';
        end if;
    end if;
end process PYRV32_CPU_EXECUTE0_INSN_EXEC;

-- "Register bypass for access hazards: read following write
PYRV32_CPU_EXECUTE0_BYPASS: process (execute0_s1bypass, regbank_tri0_data_t, regbank_tri0_data_s, execute0_s2bypass, execute0_s2bypass_d, execute0_regs1_buf, rdata_d, execute0_regs2_buf, execute0_result, execute0_mem_load_data, execute0_s1bypass_d, execute0_did_stall, execute0_did_load) is
begin
    if bool(execute0_s1bypass) then
        if bool(execute0_did_load) then
            execute0_rs1 <= execute0_mem_load_data;
        else
            execute0_rs1 <= execute0_result;
        end if;
    elsif bool(execute0_s1bypass_d) then
        execute0_rs1 <= rdata_d;
    elsif bool(execute0_did_stall) then
        execute0_rs1 <= execute0_regs1_buf;
    else
        execute0_rs1 <= regbank_tri0_data_s;
    end if;
    if bool(execute0_s2bypass) then
        if bool(execute0_did_load) then
            execute0_rs2 <= execute0_mem_load_data;
        else
            execute0_rs2 <= execute0_result;
        end if;
    elsif bool(execute0_s2bypass_d) then
        execute0_rs2 <= rdata_d;
    elsif bool(execute0_did_stall) then
        execute0_rs2 <= execute0_regs2_buf;
    else
        execute0_rs2 <= regbank_tri0_data_t;
    end if;
end process PYRV32_CPU_EXECUTE0_BYPASS;

-- Multiplexer logic to select ALU inputs
PYRV32_CPU_EXECUTE0_MUX: process (sh, execute0_mepc, execute0_action_srcpc, evt_reti, imm, action_branch, evt_exception, evt_vector, execute0_action_immediate, expc, execute0_rs1, execute0_rs2, execute0_jump_target) is
begin
    if bool(execute0_action_srcpc) then
        execute0_mux_a <= resize(expc, 32);
    else
        execute0_mux_a <= execute0_rs1;
    end if;
    if bool(execute0_action_immediate) then
        execute0_mux_sh <= sh;
        execute0_mux_b <= imm;
    else
        execute0_mux_sh <= execute0_rs2(5-1 downto 0);
        execute0_mux_b <= execute0_rs2;
    end if;
    if (bool(evt_exception) and (not bool(action_branch))) then
        newpc <= evt_vector;
    elsif bool(evt_reti) then
        newpc <= execute0_mepc;
    else
        newpc <= resize(execute0_jump_target, 15);
    end if;
end process PYRV32_CPU_EXECUTE0_MUX;

PYRV32_CPU_EXECUTE0_BRANCH_COMPARE: process (mode, func, execute0_rs1, execute0_rs2, ex_en, execute0_action_swbrk) is
    variable f: unsigned(2 downto 0);
begin
    if bool(ex_en) then
        evt_idle <= '0';
        evt_brk <= '0';
        case mode is
            when COND_BRANCH =>
                f := func;
                if ((f = 0) and (execute0_rs1 = execute0_rs2)) then
                    execute0_will_branch <= '1';
                elsif ((f = 1) and (execute0_rs1 /= execute0_rs2)) then
                    execute0_will_branch <= '1';
                elsif ((f = 4) and (signed(execute0_rs1) < signed(execute0_rs2))) then
                    execute0_will_branch <= '1';
                elsif ((f = 6) and (execute0_rs1 < execute0_rs2)) then
                    execute0_will_branch <= '1';
                elsif ((f = 5) and (signed(execute0_rs1) >= signed(execute0_rs2))) then
                    execute0_will_branch <= '1';
                elsif ((f = 7) and (execute0_rs1 >= execute0_rs2)) then
                    execute0_will_branch <= '1';
                else
                    execute0_will_branch <= '0';
                end if;
            when xRET =>
                execute0_will_branch <= '1';
            when JMP =>
                execute0_will_branch <= '1';
            when IDLE =>
                execute0_will_branch <= '0';
                evt_idle <= '1';
            when SWTRAP =>
                evt_brk <= execute0_action_swbrk;
                execute0_will_branch <= '0';
            when others =>
                execute0_will_branch <= '0';
        end case;
    else
        execute0_will_branch <= '0';
        evt_idle <= '0';
        evt_brk <= '0';
    end if;
end process PYRV32_CPU_EXECUTE0_BRANCH_COMPARE;

PYRV32_CPU_EXECUTE0_ALU0_WORKER: process (clk) is
begin
    if rising_edge(clk) then
        if bool(execute0_alu_en) then
            case execute0_alu0_alu_mode is
                when A_NOP =>
                    execute0_result <= execute0_mux_b;
                when A_ADD =>
                    execute0_result <= (execute0_mux_a + execute0_mux_b);
                when A_SUB =>
                    execute0_result <= (execute0_mux_a - execute0_mux_b);
                when A_SRL =>
                    execute0_result <= shift_right(execute0_mux_a, to_integer(execute0_mux_sh));
                when A_SRA =>
                    execute0_result <= unsigned(shift_right(signed(execute0_mux_a), to_integer(execute0_mux_sh)));
                when A_SLL =>
                    execute0_result <= shift_left(execute0_mux_a, to_integer(execute0_mux_sh));
                when A_SLT =>
                    if (signed(execute0_mux_a) < signed(execute0_mux_b)) then
                        execute0_result <= to_unsigned(1, 32);
                    else
                        execute0_result <= to_unsigned(0, 32);
                    end if;
                when A_SLTU =>
                    if (execute0_mux_a < execute0_mux_b) then
                        execute0_result <= to_unsigned(1, 32);
                    else
                        execute0_result <= to_unsigned(0, 32);
                    end if;
                when A_XOR =>
                    execute0_result <= (execute0_mux_a xor execute0_mux_b);
                when A_OR =>
                    execute0_result <= (execute0_mux_a or execute0_mux_b);
                when A_AND =>
                    execute0_result <= (execute0_mux_a and execute0_mux_b);
                when others =>
                    null;
            end case;
        end if;
    end if;
end process PYRV32_CPU_EXECUTE0_ALU0_WORKER;

-- Use CSR mepc instance

execute0_mepc <= resize(execute0_csrreg_mepc, 15);
execute0_csrreg_depc <= resize(expc, 32);

PYRV32_CPU_EXECUTE0_CSR0_WRITE: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '1') then
            execute0_csr0_csrreg_mcause <= to_unsigned(0, 32);
            execute0_csr0_csrreg_mstatus <= to_unsigned(0, 32);
            execute0_csr0_csrreg_misa <= to_unsigned(68157696, 32);
            execute0_csr0_csrreg_mtvec <= to_unsigned(0, 32);
            execute0_csrreg_mepc <= to_unsigned(0, 32);
            execute0_csr0_csrreg_dscratch0 <= to_unsigned(0, 32);
            execute0_csr0_csrreg_mie <= to_unsigned(0, 32);
        else
            if bool(action_saveret) then
                execute0_csrreg_mepc <= resize(expc, 32);
            elsif bool(execute0_csr0_csr_we) then
                case execute0_csr0_csr_addr is
                    when "001100000000" =>
                        execute0_csr0_csrreg_mstatus <= execute0_csr0_data;
                    when "001100000001" =>
                        execute0_csr0_csrreg_misa <= execute0_csr0_data;
                    when "001100000100" =>
                        execute0_csr0_csrreg_mie <= execute0_csr0_data;
                    when "001100000101" =>
                        execute0_csr0_csrreg_mtvec <= execute0_csr0_data;
                    when "001101000010" =>
                        execute0_csr0_csrreg_mcause <= execute0_csr0_data;
                    when "001101000001" =>
                        execute0_csrreg_mepc <= execute0_csr0_data;
                    when "011110100010" =>
                        execute0_csr0_csrreg_dscratch0 <= execute0_csr0_data;
                    when others =>
                end case;
            end if;
        end if;
    end if;
end process PYRV32_CPU_EXECUTE0_CSR0_WRITE;

PYRV32_CPU_EXECUTE0_CSR0_READ: process (clk) is
begin
    if rising_edge(clk) then
        if (execute0_csr0_illegal_csr = '1') then
            -- assert False report "ValueError" severity note;
        end if;
        if bool(execute0_csr0_csr_re) then
            execute0_reg_out <= execute0_csr0_reg;
        end if;
        tap_odata <= execute0_csr0_csrreg_dscratch0;
    end if;
end process PYRV32_CPU_EXECUTE0_CSR0_READ;

PYRV32_CPU_EXECUTE0_CSR0_READ_ASSIGN: process (execute0_csr0_csr_we, execute0_csr0_csr_addr, execute0_csr0_csrreg_mcause, execute0_csr0_csrreg_mstatus, execute0_csr0_csrreg_misa, execute0_csrreg_depc, execute0_csr0_csrreg_mtvec, execute0_csrreg_mepc, execute0_csr0_csr_re, execute0_csr0_csrreg_dscratch0, execute0_csr0_csrreg_mie) is
begin
    execute0_csr0_illegal_csr <= '0';
    if ((execute0_csr0_csr_re = '1') or (execute0_csr0_csr_we = '1')) then
        case execute0_csr0_csr_addr is
            when "011110100001" =>
                execute0_csr0_reg <= execute0_csrreg_depc;
            when "001100000000" =>
                execute0_csr0_reg <= execute0_csr0_csrreg_mstatus;
            when "001100000001" =>
                execute0_csr0_reg <= execute0_csr0_csrreg_misa;
            when "001100000100" =>
                execute0_csr0_reg <= execute0_csr0_csrreg_mie;
            when "001101000010" =>
                execute0_csr0_reg <= execute0_csr0_csrreg_mcause;
            when "001100000101" =>
                execute0_csr0_reg <= execute0_csr0_csrreg_mtvec;
            when "001101000001" =>
                execute0_csr0_reg <= execute0_csrreg_mepc;
            when "011110100010" =>
                execute0_csr0_reg <= execute0_csr0_csrreg_dscratch0;
            when others =>
                execute0_csr0_reg <= unsigned'("11011110101011011011111011101111");
                execute0_csr0_illegal_csr <= '1';
        end case;
    else
        execute0_csr0_reg <= unsigned'("11011110101011011011111011101111");
    end if;
end process PYRV32_CPU_EXECUTE0_CSR0_READ_ASSIGN;

PYRV32_CPU_EXECUTE0_CSR0_WRITE_ASSIGN: process (execute0_csr0_csr_we, action_dbg_wr, mode, execute0_reg_in, execute0_csr0_reg, tap_idata) is
begin
    if bool(execute0_csr0_csr_we) then
        if (mode = CP_XCH) then
            execute0_csr0_data <= execute0_reg_in;
        elsif (mode = CP_SET) then
            execute0_csr0_data <= (execute0_reg_in or execute0_csr0_reg);
        elsif (mode = CP_CLR) then
            execute0_csr0_data <= (execute0_reg_in and (not execute0_csr0_reg));
		else
            execute0_csr0_data <= (others => '0');
        end if;
    elsif bool(action_dbg_wr) then
        execute0_csr0_data <= tap_idata;
    else
        execute0_csr0_data <= to_unsigned(0, 32);
    end if;
end process PYRV32_CPU_EXECUTE0_CSR0_WRITE_ASSIGN;

-- imm contains CSR register address
PYRV32_CPU_EXECUTE0_CSR0_HANDLE_CSR_OP: process (ex_en, action_dbg_wr, execute0_csr0_csrreg_mstatus, imm, mode, tap_addr) is
begin
    execute0_csr0_csr_we <= '0';
    execute0_csr0_csr_re <= '0';
    action_upie <= execute0_csr0_csrreg_mstatus(4);
    if bool(ex_en) then
        if bool(action_dbg_wr) then
            execute0_csr0_csr_addr <= tap_addr;
            execute0_csr0_csr_we <= '1';
        else
            execute0_csr0_csr_addr <= resize(imm, 12);
        end if;
        case mode is
            when CP_XCH =>
                execute0_csr0_csr_we <= '1';
                execute0_csr0_csr_re <= '1';
            when CP_SET =>
                execute0_csr0_csr_re <= '1';
                execute0_csr0_csr_we <= '1';
            when CP_CLR =>
                execute0_csr0_csr_re <= '0';
                execute0_csr0_csr_we <= '0';
            when others =>
                null;
        end case;
	else
		execute0_csr0_csr_addr <= (others => '0');
    end if;
end process PYRV32_CPU_EXECUTE0_CSR0_HANDLE_CSR_OP;

PYRV32_CPU_EXECUTE0_REGS_BUFFER: process (clk) is
begin
    if rising_edge(clk) then
        execute0_regs1_buf <= regbank_tri0_data_s;
        execute0_regs2_buf <= regbank_tri0_data_t;
    end if;
end process PYRV32_CPU_EXECUTE0_REGS_BUFFER;


execute0_reg_in <= execute0_rs1;

PYRV32_CPU_EXECUTE0_MEMORY_ACCESS_HANDLE: process (clk) is
begin
    if rising_edge(clk) then
        execute0_did_stall <= evt_stall;
        if (not bool(evt_stall)) then
            execute0_did_load <= action_preload;
            execute0_s1bypass <= haz_s1bypass;
            execute0_s2bypass <= haz_s2bypass;
        end if;
    end if;
end process PYRV32_CPU_EXECUTE0_MEMORY_ACCESS_HANDLE;

-- Destination register multiplexing
PYRV32_CPU_EXECUTE0_REG_DEST_MUX: process (evt_data_valid, action_delay, execute0_reg_out, execute0_regd_buf, execute0_action_load, execute0_result, execute0_branch, execute0_mem_load_data, expc, execute0_csr_xs) is
begin
    if bool(action_delay) then
        if bool(evt_data_valid) then
            rdata_d <= execute0_mem_load_data;
        else
            rdata_d <= execute0_regd_buf;
        end if;
    else
        if bool(execute0_branch) then
            rdata_d <= resize(expc, 32);
        elsif bool(execute0_action_load) then
            rdata_d <= execute0_mem_load_data;
        elsif bool(execute0_csr_xs) then
            rdata_d <= execute0_reg_out;
        else
            rdata_d <= execute0_result;
        end if;
    end if;
end process PYRV32_CPU_EXECUTE0_REG_DEST_MUX;


execute0_indirect <= (execute0_mux_a + imm);
execute0_jump_target <= (execute0_mux_a + imm);

-- Buffer destination register value for delayed writeback
PYRV32_CPU_EXECUTE0_REGD_BUFFER: process (clk) is
begin
    if rising_edge(clk) then
        if bool(execute0_branch) then
            execute0_regd_buf <= resize(expc, 32);
        elsif bool(execute0_action_load) then
            execute0_regd_buf <= execute0_mem_load_data;
        elsif bool(execute0_csr_xs) then
            execute0_regd_buf <= execute0_reg_out;
        else
            execute0_regd_buf <= execute0_result;
        end if;
    end if;
end process PYRV32_CPU_EXECUTE0_REGD_BUFFER;

PYRV32_CPU_EXECUTE0_ASSIGN: process (execute0_will_branch, ex_en, execute0_reg_we_d, execute0_reg_we, action_delay) is
begin
    execute0_alu_en <= ex_en;
    action_branch <= execute0_will_branch;
    if (action_delay = '1') then
        action_reg_we <= execute0_reg_we_d;
    else
        action_reg_we <= execute0_reg_we;
    end if;
end process PYRV32_CPU_EXECUTE0_ASSIGN;

-- If we will have a WB event and src is identical dst, trigger
-- these early hazard conditions
PYRV32_CPU_HAZ_SUBSEQUENT_ACCESS: process (reg_s2, reg_s1, regd_d, action_wreg) is
    variable rd: unsigned(4 downto 0);
begin
    rd := regd_d(0);
    if (bool(action_wreg) and (rd /= 0)) then
        s1_haz <= stdl(rd = reg_s1);
        s2_haz <= stdl(rd = reg_s2);
    else
        s1_haz <= '0';
        s2_haz <= '0';
    end if;
end process PYRV32_CPU_HAZ_SUBSEQUENT_ACCESS;

-- Hazard handling:
-- 
-- * Hazard 1: write to reg that's read in the next cycle:
--   > Simply bypass register values
PYRV32_CPU_HAZARD_BYPASS: process (s1_haz, s2_haz, maybe_bypass_s1, ex_en, mode) is
begin
    if ((not bool(ex_en)) or (mode = COND_BRANCH)) then
        haz_s1bypass <= '0';
        haz_s2bypass <= '0';
    else
        if bool(s1_haz) then
            haz_s1bypass <= maybe_bypass_s1;
        else
            haz_s1bypass <= '0';
        end if;
        if bool(s2_haz) then
            haz_s2bypass <= '1';
        else
            haz_s2bypass <= '0';
        end if;
    end if;
end process PYRV32_CPU_HAZARD_BYPASS;

-- Event handling, ZPUng compatible
-- This handles IRQ events, internal exceptions and emulation. It can in this
-- case function independently of an existing CSR unit.
-- Note however, that interrupt nesting must be enabled in software.
PYRV32_CPU_EVTHANDLER: process (clk) is
begin
    if rising_edge(clk) then
        if (evt_reset = '1') then
            irqlatch0 <= '0';
            irqprio <= '0';
            action_saveret <= '0';
            irqack <= '0';
        else
            if (irqlatch0 = '0') then
                irqlatch0 <= evt_irq;
            end if;
            if (irqack = '1') then
                if ((evt_override = '1') and (action_upie = '1')) then
                    irqack <= '0';
                    irqprio <= '1';
                end if;
                if (evt_reti = '1') then
                    if (irqprio = '0') then
                        irqack <= '0';
                    else
                        irqprio <= '0';
                    end if;
                end if;
                irqlatch0 <= '0';
            elsif ((state = S_IRQ) or (state = S_IRQ_DELAY)) then
                irqack <= '1';
            end if;
            action_saveret <= evt_saveret;
        end if;
    end if;
end process PYRV32_CPU_EVTHANDLER;

-- Handles buffering of registers and stall event.
-- We stall when trying to access something that is not yet valid,
-- unless we're branching (which resolves the issue)
PYRV32_CPU_BUFFER: process (clk) is
begin
    if rising_edge(clk) then
        evt_stall <= stdl(bool(haz_access_future) and (not bool(ibranch)));
        if ((state /= S_IDLE) and (not bool(evt_stall))) then
            depc <= curpc;
            expc <= depc;
        end if;
        if bool(de_en) then
            sh <= reg_s2;
        end if;
        if (not bool(evt_stall)) then
            regd_d(1) <= regd_d(0);
            regd_d(0) <= reg_d;
        end if;
        if bool(action_delay) then
            regd_addr <= regd_d(1);
        else
            regd_addr <= regd_d(0);
        end if;
        was_delay(1) <= was_delay(0);
        was_delay(0) <= haz_load_collision;
        was_membusy(1) <= was_membusy(0);
        was_membusy(0) <= evt_membusy;
    end if;
end process PYRV32_CPU_BUFFER;

PYRV32_CPU_ASSIGN_DEBUGPC: process (clk) is
begin
    if rising_edge(clk) then
        if (ex_en = '1') then
            tap_curpc <= resize(expc, 32);
        end if;
    end if;
end process PYRV32_CPU_ASSIGN_DEBUGPC;

-- Debug Logic state machine for three pipeline stage CPU types
PYRV32_CPU_DEBUG_LOGIC0_FSM: process (clk) is
begin
    if rising_edge(clk) then
        if (tap_reset = '1') then
            debug_logic0_state <= S_RUN;
            debug_logic0_swbreak <= '0';
        else
            case debug_logic0_state is
                when S_RUN =>
                    if ((tap_emureq = '1') or (evt_brk = '1')) then
                        if ((not bool(debug_logic0_emumask)) or bool(evt_brk)) then
                            debug_logic0_state <= S_EMUACK;
                        end if;
                        if bool(evt_brk) then
                            debug_logic0_swbreak <= '1';
                        end if;
                    end if;
                when S_EMUACK =>
                    if (debug_logic0_busy = '0') then
                        debug_logic0_state <= S_EMULATION;
                    end if;
                when S_RESUME =>
                    debug_logic0_state <= S_RUN;
                when S_EMUEXEC =>
                    if bool(evt_rete) then
                        debug_logic0_state <= S_RUN;
                        debug_logic0_swbreak <= '0';
                    elsif (debug_logic0_busy = '0') then
                        debug_logic0_state <= S_EMUACK;
                    end if;
                when others => -- S_EMULATION
                    if (evt_reset = '1') then
                        debug_logic0_swbreak <= '0';
                    end if;
                    if (tap_emuexec = '1') then
                        debug_logic0_state <= S_EMUEXEC;
                    end if;
            end case;
        end if;
    end if;
end process PYRV32_CPU_DEBUG_LOGIC0_FSM;

PYRV32_CPU_DEBUG_LOGIC0_ASSIGN: process (evt_cpustat, debug_logic0_state, tap_emumask, evt_busy, tap_emuexec, debug_logic0_swbreak, evt_emumask) is
    variable ack: std_logic;
    variable t: std_logic;
    variable emulation_exec: std_logic;
begin
    ack := stdl((debug_logic0_state = S_EMUACK) or (debug_logic0_state = S_EMULATION) or (debug_logic0_state = S_EMUEXEC));
    tap_exstat <= evt_cpustat;
    tap_emuack <= ack;
    evt_emuack <= ack;
    evt_dbgbreak <= debug_logic0_swbreak;
    tap_emurdy <= stdl(debug_logic0_state = S_EMULATION);
    emulation_exec := stdl(bool(tap_emuexec) and (debug_logic0_state = S_EMULATION));
    evt_hold <= stdl(((debug_logic0_state = S_EMULATION) or (debug_logic0_state = S_EMUACK) or (debug_logic0_state = S_RESUME)) and (not bool(tap_emuexec)));
    evt_emuexec <= emulation_exec;
    evt_dbg_wr <= stdl((debug_logic0_state = S_RUN) and bool(tap_emuexec));
    t := stdl(bool(evt_emumask) and bool(tap_emumask));
    debug_logic0_emumask <= t;
    debug_logic0_busy <= stdl(bool(evt_busy) or bool(t));
end process PYRV32_CPU_DEBUG_LOGIC0_ASSIGN;

-- Pipe control
-- We need to handle the cases:
-- * IRQ event:
--   Insert '0' bubble and wait for pipeline to flush
-- * Branch effective:
--   Stall pipeline, not including fetch
-- * Exception:
--         Immediately stall pipeline including fetch, enter
--         exception mode
PYRV32_CPU_PIPECONTROL: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '1') then
            pipe_valid <= to_unsigned(0, 4);
        elsif (evt_emuexec = '1') then
            pipe_valid <= to_unsigned(2, 4);
        elsif (ibranch = '1') then
            pipe_valid <= to_unsigned(1, 4);
        elsif (pipe_clr = '1') then
            pipe_valid <= to_unsigned(0, 4);
        else
            pipe_valid <= unsigned'(pipe_valid((4 - 1)-1 downto 0) & pipe_en);
        end if;
    end if;
end process PYRV32_CPU_PIPECONTROL;


reg_d <= insn(12-1 downto 7);
reg_s1 <= insn(SLICE_RS1);
reg_s2 <= insn(SLICE_RS2);

PYRV32_CPU_DECODE0_INSTRUCTION_DECODE0_IMM_EXTEND: process (decode0_instruction_decode0_imm_extend_21, insn, decode0_instruction_decode0_immtype) is
begin
    case decode0_instruction_decode0_immtype is
        when TYPE_I =>
            decode0_pc_imm <= unsigned'(decode0_instruction_decode0_imm_extend_21 & insn(31-1 downto 20));
        when TYPE_S =>
            decode0_pc_imm <= unsigned'(decode0_instruction_decode0_imm_extend_21 & insn(31-1 downto 25) & insn(SLICE_IMML_S));
        when TYPE_B =>
            decode0_pc_imm <= unsigned'(decode0_instruction_decode0_imm_extend_21(21-1 downto 1) & insn(7) & insn(31-1 downto 25) & insn(12-1 downto 8) & to_unsigned(0, 1));
        when TYPE_U =>
            decode0_pc_imm <= unsigned'(insn(32-1 downto 12) & to_unsigned(0, 12));
        when TYPE_J =>
            decode0_pc_imm <= unsigned'(decode0_instruction_decode0_imm_extend_21(21-1 downto 9) & insn(20-1 downto 12) & insn(20) & insn(31-1 downto 25) & insn(25-1 downto 21) & to_unsigned(0, 1));
        when others =>
            decode0_pc_imm <= MYHDL39_UNDEFINED(32);
    end case;
end process PYRV32_CPU_DECODE0_INSTRUCTION_DECODE0_IMM_EXTEND;

PYRV32_CPU_DECODE0_INSTRUCTION_DECODE0_WORKER: process (insn) is
    variable func3: unsigned(31 downto 0);
    variable preload: std_logic;
    variable enable_alu: std_logic;
    variable itype: t_enum_t_itype_5;
    variable func12: unsigned(31 downto 0);
    variable m: t_enum_t_mode_2;
    variable aop: t_enum_t_aluop_3;
    variable load_mode: t_enum_t_lmode_6;
    variable op: unsigned(31 downto 0);
begin
    op := resize(insn(OPCODE), 32);
    enable_alu := '0';
    m := NOP;
    aop := A_NOP;
    decode0_de_action_immediate <= '0';
    decode0_de_action_srcpc <= '0';
    decode0_de_action_swbrk <= '0';
    itype := TYPE_NONE;
    func3 := resize(insn(FUNCT3), 32);
    preload := '0';
    load_mode := LW;
    case op is
        when "00000000000000000000000000000011" =>
            itype := TYPE_I;
            aop := A_NOP;
            preload := '1';
            m := LOAD;
            case func3 is
                when "00000000000000000000000000000000" =>
                    load_mode := LB;
                when "00000000000000000000000000000001" =>
                    load_mode := LH;
                when "00000000000000000000000000000010" =>
                    load_mode := LW;
                when "00000000000000000000000000000100" =>
                    load_mode := LBU;
                when "00000000000000000000000000000101" =>
                    load_mode := LHU;
                when others =>
                    m := ILLEGAL;
            end case;
        when "00000000000000000000000000100011" =>
            itype := TYPE_S;
            decode0_de_action_immediate <= '1';
            m := STORE;
            aop := A_ADD;
            case func3 is
                when "00000000000000000000000000000000" =>
                    load_mode := LB;
                when "00000000000000000000000000000001" =>
                    load_mode := LH;
                when "00000000000000000000000000000010" =>
                    load_mode := LW;
                when others =>
                    m := ILLEGAL;
            end case;
        when "00000000000000000000000000010111" =>
            itype := TYPE_U;
            m := ALU;
            aop := A_ADD;
            decode0_de_action_immediate <= '1';
            decode0_de_action_srcpc <= '1';
        when "00000000000000000000000000110111" =>
            itype := TYPE_U;
            decode0_de_action_immediate <= '1';
            m := IMMEDIATE;
        when "00000000000000000000000001101111" =>
            m := JMP;
            aop := A_ADD;
            decode0_de_action_srcpc <= '1';
            decode0_de_action_immediate <= '1';
            itype := TYPE_J;
        when "00000000000000000000000001100111" =>
            m := JMP;
            aop := A_ADD;
            decode0_de_action_immediate <= '1';
            itype := TYPE_I;
        when "00000000000000000000000001100011" =>
            m := COND_BRANCH;
            itype := TYPE_B;
            aop := A_ADD;
            decode0_de_action_srcpc <= '1';
            decode0_de_action_immediate <= '1';
            case func3 is
                when "00000000000000000000000000000000" =>
                    null;
                when "00000000000000000000000000000001" =>
                    null;
                when "00000000000000000000000000000100" =>
                    null;
                when "00000000000000000000000000000101" =>
                    null;
                when "00000000000000000000000000000110" =>
                    null;
                when "00000000000000000000000000000111" =>
                    null;
                when others =>
                    m := ILLEGAL;
            end case;
        when "00000000000000000000000000010011" =>
            itype := TYPE_I;
            m := ALU;
            enable_alu := '1';
            decode0_de_action_immediate <= '1';
        when "00000000000000000000000000110011" =>
            itype := TYPE_R;
            m := ALU;
            enable_alu := '1';
        when "00000000000000000000000001110011" =>
            itype := TYPE_I;
            m := CONTROL;
            if (func3 = 0) then
                func12 := resize(insn(FUNCT12), 32);
                m := SWTRAP;
                case func12 is
                    when "00000000000000000000000000000001" =>
                        decode0_de_action_swbrk <= '1';
                    when "00000000000000000000011110110010" =>
                        m := RETE;
                    when "00000000000000000000001100000010" =>
                        m := xRET;
                    when "00000000000000000000000100000101" =>
                        m := IDLE;
                    when others =>
                        m := ILLEGAL;
                end case;
            elsif (func3 = 1) then
                m := CP_XCH;
            elsif (func3 = 2) then
                m := CP_SET;
            elsif (func3 = 3) then
                m := CP_CLR;
            end if;
        when others =>
            m := ILLEGAL;
    end case;
    if bool(enable_alu) then
        case func3 is
            when "00000000000000000000000000000000" =>
                if (itype = TYPE_I) then
                    aop := A_ADD;
                elsif bool(insn(30)) then
                    aop := A_SUB;
                else
                    aop := A_ADD;
                end if;
            when "00000000000000000000000000000001" =>
                aop := A_SLL;
            when "00000000000000000000000000000010" =>
                aop := A_SLT;
            when "00000000000000000000000000000011" =>
                aop := A_SLTU;
            when "00000000000000000000000000000100" =>
                aop := A_XOR;
            when "00000000000000000000000000000101" =>
                if bool(insn(30)) then
                    aop := A_SRA;
                else
                    aop := A_SRL;
                end if;
            when "00000000000000000000000000000110" =>
                aop := A_OR;
            when "00000000000000000000000000000111" =>
                aop := A_AND;
            when others =>
                null;
        end case;
    end if;
    decode0_instruction_decode0_imm31 <= insn(31);
    decode0_instruction_decode0_immtype <= itype;
    decode0_de_action_lmode <= load_mode;
    if ((itype = TYPE_S) or (itype = TYPE_B)) then
        decode0_de_action_wreg <= '0';
    else
        decode0_de_action_wreg <= '1';
    end if;
    decode0_de_action_aop <= aop;
    decode0_pc_mode <= m;
    decode0_pc_func <= resize(func3, 6);
    
end process PYRV32_CPU_DECODE0_INSTRUCTION_DECODE0_WORKER;

-- Standard PyPS instruction decoder
PYRV32_CPU_DECODE0_INSN_DECODE: process (clk) is
begin
    if rising_edge(clk) then
        if bool(de_en) then
            mode <= decode0_pc_mode;
            func <= resize(decode0_pc_func, 3);
            imm <= decode0_pc_imm;
            execute0_action_swbrk <= decode0_de_action_swbrk;
            execute0_action_srcpc <= decode0_de_action_srcpc;
            execute0_alu0_alu_mode <= decode0_de_action_aop;
            decode0_action_lmode <= decode0_de_action_lmode;
            execute0_action_immediate <= decode0_de_action_immediate;
            action_wreg <= decode0_de_action_wreg;
        end if;
    end if;
end process PYRV32_CPU_DECODE0_INSN_DECODE;


regd_data <= rdata_d;
regd_we <= action_reg_we;


branch <= action_branch;

PYRV32_CPU_FETCH0_FORESEE: process (fetch0_pc, newpc, ibranch) is
begin
    if (ibranch = '1') then
        fetch0_nextpc <= resize(newpc, 32);
    else
        fetch0_nextpc <= (fetch0_pc + 4);
    end if;
    imem_iaddr <= resize(fetch0_pc(15-1 downto 0), 20);
    curpc <= resize(fetch0_pc, 15);
end process PYRV32_CPU_FETCH0_FORESEE;

PYRV32_CPU_FETCH0_PROCEED: process (clk) is
begin
    if rising_edge(clk) then
        if (reset = '1') then
            fetch0_pc <= to_unsigned(0, 32);
        else
            if bool(fe_en) then
                fetch0_pc <= fetch0_nextpc;
                
            end if;
        end if;
    end if;
end process PYRV32_CPU_FETCH0_PROCEED;

PYRV32_CPU_MEMIO_IMEM_DATA_SELECT: process (dmem_rdata, memio_was_imem, execute0_mem_addr, action_preload, imem_rdata, execute0_action_store) is
begin
    if ((execute0_mem_addr(16) = '0') and (execute0_mem_addr(18) = '0')) then
        memio_is_imem <= stdl(bool(action_preload) or bool(execute0_action_store));
    else
        memio_is_imem <= '0';
    end if;
    if (memio_was_imem = '1') then
        memio_data_mux <= imem_rdata;
    else
        memio_data_mux <= dmem_rdata;
    end if;
end process PYRV32_CPU_MEMIO_IMEM_DATA_SELECT;

PYRV32_CPU_MEMIO_IMEM_DATA_ACCESS_REGISTER: process (clk) is
begin
    if rising_edge(clk) then
        memio_was_imem <= memio_is_imem;
    end if;
end process PYRV32_CPU_MEMIO_IMEM_DATA_ACCESS_REGISTER;


imem_write <= stdl(bool(execute0_action_store) and bool(memio_is_imem));
imem_wdata <= execute0_mem_store_data;


imem_read <= stdl(bool(action_preload) and bool(memio_is_imem));
imem_daddr <= execute0_mem_addr(20-1 downto 0);

PYRV32_CPU_MEMIO_WORKER: process (clk) is
begin
    if rising_edge(clk) then
        memio_dmem_busy_d <= dmem_busy;
        if (not bool(memio_dmem_busy_d)) then
            memio_mode_d <= decode0_action_lmode;
        end if;
        execute0_action_load <= action_preload;
    end if;
end process PYRV32_CPU_MEMIO_WORKER;

PYRV32_CPU_MEMIO_ASSIGN: process (memio_mode_d, dmem_rdata, execute0_mem_addr, execute0_mem_store_data, action_preload, decode0_action_lmode, memio_data_mux, execute0_action_store) is
    variable m: t_enum_t_lmode_6;
begin
    dmem_we <= execute0_action_store;
    dmem_addr <= execute0_mem_addr(20-1 downto 0);
    dmem_wdata <= execute0_mem_store_data;
    dmem_re <= action_preload;
    case memio_mode_d is
        when LB =>
            execute0_mem_load_data <= unsigned(resize(signed(dmem_rdata(8-1 downto 0)), 32));
        when LH =>
            execute0_mem_load_data <= unsigned(resize(signed(dmem_rdata(16-1 downto 0)), 32));
        when LBU =>
            execute0_mem_load_data <= resize(dmem_rdata(8-1 downto 0), 32);
        when LHU =>
            execute0_mem_load_data <= resize(dmem_rdata(16-1 downto 0), 32);
        when others =>
            execute0_mem_load_data <= memio_data_mux;
    end case;
    m := decode0_action_lmode;
    case m is
        when LB =>
            dmem_wsize <= to_unsigned(0, 2);
        when LH =>
            dmem_wsize <= to_unsigned(1, 2);
        when LBU =>
            dmem_wsize <= to_unsigned(0, 2);
        when LHU =>
            dmem_wsize <= to_unsigned(1, 2);
        when others =>
            dmem_wsize <= to_unsigned(2, 2);
    end case;
end process PYRV32_CPU_MEMIO_ASSIGN;

end architecture MyHDL;
