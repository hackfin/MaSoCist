-- File: ZPUng.vhd
-- Generated by MyHDL 0.11
-- Date: Mon Feb 17 12:57:15 2020


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_011.all;

entity ZPUng is
    port (
        clk: in std_logic;
        reset: in std_logic;
        irq: in std_logic;
        override: in std_logic;
        exc: in std_logic;
        cache_wait: in std_logic;
        evaddr: in unsigned(13 downto 0);
        tap_reset: in std_logic;
        tap_emumask: in std_logic;
        tap_exstat: out unsigned(7 downto 0);
        tap_idata: in unsigned(31 downto 0);
        tap_emuexec: in std_logic;
        tap_odata: out unsigned(31 downto 0);
        tap_emuir: in unsigned(7 downto 0);
        tap_emuack: out std_logic;
        tap_emurdy: out std_logic;
        tap_curpc: out unsigned(31 downto 0);
        tap_emureq: in std_logic;
        mmr_we: out std_logic;
        mmr_busy: in std_logic;
        mmr_addr: out unsigned(14 downto 0);
        mmr_re: out std_logic;
        mmr_wdata: out unsigned(31 downto 0);
        mmr_rdata: in unsigned(31 downto 0);
        imem_write: out std_logic;
        imem_idata: in unsigned(31 downto 0);
        imem_read: out std_logic;
        imem_daddr: out unsigned(11 downto 0);
        imem_wdata: out unsigned(31 downto 0);
        imem_rdata: in unsigned(31 downto 0);
        imem_iaddr: out unsigned(11 downto 0)
    );
end entity ZPUng;
-- Variant: v0.2 'legacy small'
-- - ZPUv4 opcode compatible
-- - Regress test zpu-elf-gcc 3.4.2 PASSED
-- 
--      (c) 2013-2018, <hackfin@section5.ch>
-- 
-- THIS VARIANT IS RELEASED ONLY FOR EVALUATION PURPOSES.
--     Contact author for licensing details.
--    
--     Configuration:
--     - Separate Stack and PROG/DATA memory
--     - No prefetch stage (slow)
--     - ZPU 8 bit opcode translation, popint support.
--     - Simple Load/Store delays
--     - Shortcut and hazard resolving
--     - StdTAP debug v0 (simple) interface enabled

architecture MyHDL of ZPUng is


subtype F_WA_MODE is integer range 5-1 downto 3;
subtype MEM_ADDR_SLICE is integer range 17-1 downto 2;
subtype OPMODE_SPOP is integer range 8-1 downto 4;
subtype F_PC_MODE is integer range 15-1 downto 12;
subtype F_WR_MODE is integer range 9-1 downto 5;
subtype OPMODE_SPLDST is integer range 8-1 downto 5;
subtype OPMODE_GEN is integer range 4-1 downto 0;


type t_enum_dbg_state_3 is (
	S_RUN,
	S_RESUME,
	S_EMUACK,
	S_EMULATION,
	S_EMUEXEC
	);
type t_enum_t_mode_2 is (
	M_NOP,
	M_IMM,
	M_EMUINSN,
	M_LDSP,
	M_STSP,
	M_ADDSP,
	M_SWBRK,
	M_EXCPT,
	M_PUSHSP,
	M_POPPC,
	M_ALU,
	M_LOAD,
	M_NOT,
	M_FLIP,
	M_STORE,
	M_POPSP,
	M_REARM,
	M_POPINT
	);
type t_enum_x_state_1 is (
	S_RESET,
	S_ILLEGAL,
	S_IDLE,
	S_EXEC,
	S_IRQ,
	S_EXC,
	S_HOLD,
	S_RESUME,
	S_ALU,
	S_ALU1,
	S_ALU2,
	S_SYNC,
	S_BRANCH_SYNC,
	S_SAVE,
	S_WAIT,
	S_SAVEADD,
	S_LOAD,
	S_LOAD1,
	S_STORE1,
	S_STORE2
	);

signal iobusy: std_logic;
signal imm: signed (6 downto 0);
signal pc: unsigned(14 downto 0);
signal state: t_enum_x_state_1;
signal branch: std_logic;
signal insn: unsigned(7 downto 0);
signal func: unsigned(2 downto 0);
signal sp: unsigned(14 downto 0);
signal evt_override: std_logic;
signal mode: t_enum_t_mode_2;
signal evt_cache_wait: std_logic;
signal spval: unsigned(31 downto 0);
signal execute_vliw0_in_exc: std_logic;
signal execute_vliw0_sp_pop: unsigned(14 downto 0);
signal execute_vliw0_irqprio: std_logic;
signal execute_vliw0_in_reset: std_logic;
signal execute_vliw0_idst0: std_logic;
signal execute_vliw0_in_ucode: std_logic;
signal execute_vliw0_wreg: unsigned(31 downto 0);
signal execute_vliw0_evt_brk: std_logic;
signal execute_vliw0_irqack: std_logic;
signal execute_vliw0_evt_reset: std_logic;
signal execute_vliw0_pb_addr: unsigned(14 downto 0);
signal execute_vliw0_is_im: std_logic;
signal execute_vliw0_ptr: unsigned(14 downto 0);
signal execute_vliw0_sp_push: unsigned(14 downto 0);
signal execute_vliw0_evt_hold_pc: std_logic;
signal execute_vliw0_evt_dbgbreak: std_logic;
signal execute_vliw0_idim_save: std_logic;
signal execute_vliw0_busy: std_logic;
signal execute_vliw0_shortcut: std_logic;
signal execute_vliw0_will_branch: std_logic;
signal execute_vliw0_idim: std_logic;
signal execute_vliw0_nextpc: unsigned(14 downto 0);
signal execute_vliw0_evt_busy: std_logic;
signal execute_vliw0_evt_hold: std_logic;
signal execute_vliw0_aluop: unsigned(2 downto 0);
signal execute_vliw0_evt_cpustat: unsigned(7 downto 0);
signal execute_vliw0_evt_toggle_emu: std_logic;
signal execute_vliw0_waddr: unsigned(14 downto 0);
signal execute_vliw0_idst1: std_logic;
signal execute_vliw0_offset: unsigned(4 downto 0);
signal execute_vliw0_pa_we: std_logic;
signal execute_vliw0_nextstate: t_enum_x_state_1;
signal execute_vliw0_vliw: unsigned(16 downto 0);
signal execute_vliw0_acc: unsigned(31 downto 0);
signal execute_vliw0_pb_rdata: unsigned(31 downto 0);
signal execute_vliw0_pa_wdata: unsigned(31 downto 0);
signal execute_vliw0_irqlatch: std_logic;
signal execute_vliw0_write: std_logic;
signal execute_vliw0_evt_emuack: std_logic;
signal execute_vliw0_pa_addr: unsigned(14 downto 0);
signal execute_vliw0_evt_emumask: std_logic;
signal fetch0_mod_d: unsigned(1 downto 0);
signal fetch0_emuexec: std_logic;
signal debug_logic0_swbreak: std_logic;
signal debug_logic0_busy: std_logic;
signal debug_logic0_state: t_enum_dbg_state_3;
signal debug_logic0_emumask: std_logic;
signal memmgr0_iomem_d: std_logic;
signal memmgr0_sb_rdata: unsigned(31 downto 0);
signal memmgr0_sb_addr: unsigned(8 downto 0);
signal memmgr0_sa_we: std_logic;
signal memmgr0_sa_wdata: unsigned(31 downto 0);
signal memmgr0_sa_addr: unsigned(8 downto 0);
signal memmgr0_dmem_d: std_logic;
signal memmgr0_stackmem0_data: unsigned(31 downto 0);
type t_array_memmgr0_stackmem0_ram is array(0 to 512-1) of unsigned(31 downto 0);
signal memmgr0_stackmem0_ram: t_array_memmgr0_stackmem0_ram;

function MYHDL5_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL5_wr;

function MYHDL6_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL6_wa;

function MYHDL7_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL7_wa;

function MYHDL8_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL8_wr;

function MYHDL9_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL9_wa;

function MYHDL10_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL10_wr;

function MYHDL11_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL11_wa;

function MYHDL12_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL12_wa;

function MYHDL13_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL13_wr;

function MYHDL14_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL14_wa;

function MYHDL15_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL15_wr;

function MYHDL16_newpc(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 12));
end function MYHDL16_newpc;

function MYHDL17_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL17_wa;

function MYHDL18_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL18_wr;

function MYHDL19_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL19_wa;

function MYHDL20_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL20_wr;

function MYHDL21_newpc(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 12));
end function MYHDL21_newpc;

function MYHDL22_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL22_wr;

function MYHDL23_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL23_wa;

function MYHDL24_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL24_wa;

function MYHDL25_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL25_wr;

function MYHDL26_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL26_wa;

function MYHDL27_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL27_wr;

function MYHDL28_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL28_wa;

function MYHDL29_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL29_wr;

function MYHDL30_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL30_wa;

function MYHDL31_newpc(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 12));
end function MYHDL31_newpc;

function MYHDL32_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL32_wa;

function MYHDL33_wr(
    v: in integer
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL33_wr;

function MYHDL34_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL34_wr;

function MYHDL35_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL35_wa;

function MYHDL36_wr(
    v: in integer
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL36_wr;

function MYHDL37_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL37_wr;

function MYHDL38_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL38_wa;

function MYHDL39_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL39_wr;

function MYHDL40_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL40_wr;

function MYHDL41_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL41_wa;

function MYHDL42_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL42_wa;

function MYHDL43_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL43_wr;

function MYHDL44_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL44_wr;

function MYHDL45_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL45_wr;

function MYHDL46_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL46_wa;

function MYHDL47_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL47_wr;

function MYHDL48_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL48_wr;

function MYHDL49_newpc(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 12));
end function MYHDL49_newpc;

function MYHDL50_wa(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 3));
end function MYHDL50_wa;

function MYHDL51_wr(
    v: in natural
    ) return integer is
begin
    return (v * (2 ** 5));
end function MYHDL51_wr;

function MYHDL54_flip(
    a: in unsigned
    ) return unsigned is
    variable b: unsigned(31 downto 0);
    variable l: natural;
begin
    l := 32;
    b := a;
    for i in 0 to l-1 loop
        b(i) := a(((l - i) - 1));
    end loop;
    return b;
end function MYHDL54_flip;

function MYHDL63_is_mmr(
    addr: in unsigned
    ) return std_logic is
begin
    if bool(addr(14)) then
        return '1';
    else
        return '0';
    end if;
end function MYHDL63_is_mmr;

function MYHDL64_is_dmem(
    addr: in unsigned
    ) return std_logic is
begin
    if ((addr(12) = '0') or (addr(14-1 downto (12 + 1)) /= 0)) then
        return '1';
    else
        return '0';
    end if;
end function MYHDL64_is_dmem;

function MYHDL65_is_mmr(
    addr: in unsigned
    ) return std_logic is
begin
    if bool(addr(14)) then
        return '1';
    else
        return '0';
    end if;
end function MYHDL65_is_mmr;

function MYHDL66_is_dmem(
    addr: in unsigned
    ) return std_logic is
begin
    if ((addr(12) = '0') or (addr(14-1 downto (12 + 1)) /= 0)) then
        return '1';
    else
        return '0';
    end if;
end function MYHDL66_is_dmem;

function MYHDL70_is_dmem(
    addr: in unsigned
    ) return std_logic is
begin
    if ((addr(12) = '0') or (addr(14-1 downto (12 + 1)) /= 0)) then
        return '1';
    else
        return '0';
    end if;
end function MYHDL70_is_dmem;

function MYHDL71_is_mmr(
    addr: in unsigned
    ) return std_logic is
begin
    if bool(addr(14)) then
        return '1';
    else
        return '0';
    end if;
end function MYHDL71_is_mmr;

begin




ZPUNG_EXECUTE_VLIW0_SELECT: process (reset, execute_vliw0_wreg, execute_vliw0_sp_pop, execute_vliw0_pb_rdata, sp, execute_vliw0_idst1, execute_vliw0_idst0, state, execute_vliw0_nextpc, execute_vliw0_offset, execute_vliw0_vliw) is
    variable b: std_logic;
    variable is_in_ucode: std_logic;
    variable bypass: std_logic;
begin
    bypass := '0';
    execute_vliw0_shortcut <= '0';
    execute_vliw0_ptr <= sp;
    execute_vliw0_will_branch <= execute_vliw0_vliw(14);
    execute_vliw0_evt_reset <= reset;
    execute_vliw0_evt_brk <= execute_vliw0_vliw(15);
    is_in_ucode := stdl(execute_vliw0_nextpc < 1024);
    execute_vliw0_in_ucode <= is_in_ucode;
    b := stdl((state /= S_EXEC) and (state /= S_HOLD));
    execute_vliw0_busy <= stdl(state = S_LOAD);
    execute_vliw0_evt_busy <= b;
    execute_vliw0_evt_emumask <= is_in_ucode;
    if (state = S_STORE2) then
        execute_vliw0_ptr <= execute_vliw0_sp_pop;
    elsif (state = S_EXEC) then
        if (execute_vliw0_vliw(1) = '1') then
            execute_vliw0_ptr <= execute_vliw0_sp_pop;
            if bool(execute_vliw0_idst0) then
                execute_vliw0_shortcut <= '1';
                bypass := '1';
            elsif bool(execute_vliw0_idst1) then
                bypass := '1';
            end if;
        elsif (bool(execute_vliw0_vliw(0)) and (execute_vliw0_vliw(F_WR_MODE) = 1)) then
            if ((execute_vliw0_idst0 = '1') or (execute_vliw0_idst1 = '1')) then
                execute_vliw0_shortcut <= '1';
                bypass := '1';
            end if;
        elsif (execute_vliw0_vliw(F_WA_MODE) = 3) then
            execute_vliw0_ptr <= (sp + execute_vliw0_offset);
        end if;
    end if;
    if bool(bypass) then
        spval <= execute_vliw0_wreg;
    else
        spval <= execute_vliw0_pb_rdata;
    end if;
end process ZPUNG_EXECUTE_VLIW0_SELECT;

-- Address muxing
ZPUNG_EXECUTE_VLIW0_ADDRMUX: process (execute_vliw0_waddr, execute_vliw0_idst1, execute_vliw0_write, execute_vliw0_wreg, execute_vliw0_vliw, spval, execute_vliw0_ptr) is
begin
    if bool(execute_vliw0_vliw(10)) then
        execute_vliw0_pb_addr <= spval(MEM_ADDR_SLICE);
    else
        execute_vliw0_pb_addr <= execute_vliw0_ptr;
    end if;
    execute_vliw0_pa_addr <= execute_vliw0_waddr;
    execute_vliw0_pa_we <= execute_vliw0_write;
    if ((execute_vliw0_vliw(11) = '1') and (execute_vliw0_idst1 = '1')) then
        execute_vliw0_pa_wdata <= spval;
    else
        execute_vliw0_pa_wdata <= execute_vliw0_wreg;
    end if;
end process ZPUNG_EXECUTE_VLIW0_ADDRMUX;

-- State machine. VERY UGLY. There are many priorities to sort out.
-- Therefore it may be as ugly as the Linux scheduler...
ZPUNG_EXECUTE_VLIW0_FSM: process (clk) is
    variable can_interrupt: std_logic;
begin
    if rising_edge(clk) then
        execute_vliw0_aluop <= (func - 5);
        branch <= execute_vliw0_will_branch;
        if (execute_vliw0_evt_toggle_emu = '1') then
            execute_vliw0_idim_save <= execute_vliw0_idim;
        end if;
        if (execute_vliw0_irqack = '1') then
            if (evt_override = '1') then
                execute_vliw0_irqack <= '0';
                execute_vliw0_irqprio <= '1';
            end if;
            if (execute_vliw0_vliw(16) = '1') then
                if (execute_vliw0_irqprio = '0') then
                    execute_vliw0_irqack <= '0';
                else
                    execute_vliw0_irqprio <= '0';
                end if;
            end if;
            execute_vliw0_irqlatch <= '0';
        elsif ((state = S_EXEC) or (state = S_EXC)) then
            if ((execute_vliw0_evt_emuack = '0') and (execute_vliw0_will_branch = '0')) then
                execute_vliw0_irqlatch <= irq;
            end if;
        end if;
        execute_vliw0_in_exc <= exc;
        can_interrupt := stdl(((execute_vliw0_irqlatch = '1') and (execute_vliw0_irqack = '0') and (execute_vliw0_is_im = '0')) and (execute_vliw0_evt_emuack = '0'));
        if (reset = '1') then
            state <= S_RESET;
            execute_vliw0_idim_save <= '0';
            execute_vliw0_in_exc <= '0';
            execute_vliw0_irqprio <= '0';
            execute_vliw0_irqack <= '0';
            execute_vliw0_irqlatch <= '0';
        elsif ((exc = '1') and (execute_vliw0_in_exc = '0')) then
            state <= S_EXC;
        elsif ((execute_vliw0_nextstate = S_EXEC) and (can_interrupt = '1')) then
            execute_vliw0_irqack <= '1';
            state <= S_IRQ;
        elsif bool(execute_vliw0_shortcut) then
            if (execute_vliw0_vliw(F_WA_MODE) = 2) then
                state <= S_STORE2;
            elsif (mode = M_ALU) then
                state <= S_ALU1;
            elsif (mode = M_POPPC) then
                state <= execute_vliw0_nextstate;
            elsif (mode = M_IMM) then
                null;
            elsif (mode = M_POPINT) then
                state <= execute_vliw0_nextstate;
            elsif (mode = M_REARM) then
                state <= execute_vliw0_nextstate;
            elsif (mode = M_POPSP) then
                state <= execute_vliw0_nextstate;
            elsif (mode = M_EMUINSN) then
                null;
            elsif (mode = M_FLIP) then
                null;
            elsif (mode = M_NOT) then
                null;
            elsif (mode = M_STSP) then
                null;
            elsif (mode = M_ADDSP) then
                state <= execute_vliw0_nextstate;
            elsif (mode = M_LDSP) then
                state <= execute_vliw0_nextstate;
            elsif (mode = M_LOAD) then
                state <= execute_vliw0_nextstate;
            else
                assert False report "TypeError" severity note;
            end if;
        else
            state <= execute_vliw0_nextstate;
        end if;
    end if;
end process ZPUNG_EXECUTE_VLIW0_FSM;

-- Translate ZPU instruction to VLIW
ZPUNG_EXECUTE_VLIW0_TRANSLATE: process (mode, state, execute_vliw0_offset, execute_vliw0_aluop, execute_vliw0_idim, execute_vliw0_idst0, execute_vliw0_evt_hold, execute_vliw0_evt_emuack, evt_cache_wait, iobusy, execute_vliw0_irqlatch) is
    variable stspflags: integer;
    variable f: integer;
begin
    execute_vliw0_vliw <= to_unsigned(0, 17);
    execute_vliw0_nextstate <= S_ILLEGAL;
    case state is
        when S_RESET =>
            execute_vliw0_nextstate <= S_EXEC;
        when S_EXEC =>
            if (execute_vliw0_evt_hold = '1') then
                execute_vliw0_nextstate <= S_HOLD;
                execute_vliw0_vliw <= to_unsigned(4096, 17);
            elsif (mode = M_IMM) then
                f := ((MYHDL5_wr(3) + MYHDL6_wa(1)) + 512);
                if bool(execute_vliw0_idim) then
                    execute_vliw0_vliw <= to_unsigned(f, 17);
                else
                    execute_vliw0_vliw <= to_unsigned(f + 1, 17);
                end if;
                execute_vliw0_nextstate <= S_EXEC;
            elsif (mode = M_STSP) then
                stspflags := (((2 + MYHDL7_wa(3)) + MYHDL8_wr(1)) + 512);
                if (execute_vliw0_offset = 1) then
                    execute_vliw0_vliw <= to_unsigned(stspflags + 2048, 17);
                else
                    execute_vliw0_vliw <= to_unsigned(stspflags, 17);
                end if;
                execute_vliw0_nextstate <= S_EXEC;
            elsif (mode = M_LDSP) then
                if ((execute_vliw0_offset = 0) and (execute_vliw0_idst0 = '1')) then
                    execute_vliw0_nextstate <= S_EXEC;
                    execute_vliw0_vliw <= to_unsigned(((1 + MYHDL9_wa(1)) + MYHDL10_wr(1)) + 512, 17);
                else
                    execute_vliw0_nextstate <= S_SAVE;
                    execute_vliw0_vliw <= to_unsigned(4096 + MYHDL11_wa(3), 17);
                end if;
            elsif (mode = M_ADDSP) then
                if ((execute_vliw0_offset = 0) and (execute_vliw0_idst0 = '1')) then
                    execute_vliw0_vliw <= to_unsigned(((3 + MYHDL12_wa(1)) + MYHDL13_wr(8)) + 512, 17);
                    execute_vliw0_nextstate <= S_EXEC;
                else
                    execute_vliw0_vliw <= to_unsigned((4096 + MYHDL14_wa(3)) + MYHDL15_wr(1), 17);
                    execute_vliw0_nextstate <= S_WAIT;
                end if;
            elsif (mode = M_EMUINSN) then
                execute_vliw0_vliw <= to_unsigned((((MYHDL16_newpc(6) + 1) + MYHDL17_wa(1)) + MYHDL18_wr(2)) + 512, 17);
                execute_vliw0_nextstate <= S_BRANCH_SYNC;
            elsif (mode = M_PUSHSP) then
                execute_vliw0_vliw <= to_unsigned(((1 + MYHDL19_wa(1)) + MYHDL20_wr(4)) + 512, 17);
                execute_vliw0_nextstate <= S_EXEC;
            elsif (mode = M_POPPC) then
                execute_vliw0_vliw <= to_unsigned(MYHDL21_newpc(7) + 2, 17);
                execute_vliw0_nextstate <= S_BRANCH_SYNC;
            elsif (mode = M_ALU) then
                execute_vliw0_vliw <= to_unsigned((4096 + 2) + MYHDL22_wr(1), 17);
                execute_vliw0_nextstate <= S_ALU1;
            elsif (mode = M_LOAD) then
                execute_vliw0_vliw <= to_unsigned(((4096 + 3) + MYHDL23_wa(1)) + 1024, 17);
                execute_vliw0_nextstate <= S_LOAD;
            elsif (mode = M_NOT) then
                execute_vliw0_vliw <= to_unsigned(((3 + MYHDL24_wa(1)) + MYHDL25_wr(5)) + 512, 17);
                execute_vliw0_nextstate <= S_EXEC;
            elsif (mode = M_FLIP) then
                execute_vliw0_vliw <= to_unsigned(((3 + MYHDL26_wa(1)) + MYHDL27_wr(6)) + 512, 17);
                execute_vliw0_nextstate <= S_EXEC;
            elsif (mode = M_STORE) then
                execute_vliw0_vliw <= to_unsigned(((4096 + 2) + MYHDL28_wa(2)) + MYHDL29_wr(1), 17);
                execute_vliw0_nextstate <= S_STORE1;
            elsif (mode = M_POPSP) then
                execute_vliw0_vliw <= to_unsigned(((4096 + 2) + 4) + MYHDL30_wa(1), 17);
                execute_vliw0_nextstate <= S_SYNC;
            elsif (mode = M_POPINT) then
                execute_vliw0_vliw <= to_unsigned((MYHDL31_newpc(7) + 2) + 65536, 17);
                execute_vliw0_nextstate <= S_BRANCH_SYNC;
            elsif (mode = M_REARM) then
                execute_vliw0_vliw <= to_unsigned(65536, 17);
                execute_vliw0_nextstate <= S_EXEC;
            elsif (mode = M_NOP) then
                execute_vliw0_nextstate <= S_EXEC;
            elsif (mode = M_SWBRK) then
                execute_vliw0_vliw <= to_unsigned(4096 + 32768, 17);
                if (execute_vliw0_evt_emuack = '1') then
                    execute_vliw0_nextstate <= S_RESUME;
                else
                    execute_vliw0_nextstate <= S_EXEC;
                end if;
            else
                execute_vliw0_vliw <= to_unsigned(0, 17);
            end if;
        when S_ALU1 =>
            if (0 = 1) then
                execute_vliw0_vliw <= to_unsigned((MYHDL32_wa(1) + MYHDL33_wr(to_integer(execute_vliw0_aluop))) + MYHDL34_wr(8), 17);
                execute_vliw0_nextstate <= S_ALU2;
            else
                execute_vliw0_vliw <= to_unsigned(((MYHDL35_wa(1) + MYHDL36_wr(to_integer(execute_vliw0_aluop))) + MYHDL37_wr(8)) + 512, 17);
                execute_vliw0_nextstate <= S_EXEC;
            end if;
        when S_ALU2 =>
            execute_vliw0_vliw <= to_unsigned((MYHDL38_wa(1) + MYHDL39_wr(7)) + 512, 17);
            execute_vliw0_nextstate <= S_EXEC;
        when S_LOAD =>
            execute_vliw0_vliw <= to_unsigned(4096 + MYHDL40_wr(1), 17);
            if (iobusy = '1') then
                execute_vliw0_nextstate <= S_LOAD;
            else
                execute_vliw0_nextstate <= S_LOAD1;
            end if;
        when S_LOAD1 =>
            execute_vliw0_vliw <= to_unsigned(MYHDL41_wa(1) + 512, 17);
            execute_vliw0_nextstate <= S_EXEC;
        when S_SAVE =>
            execute_vliw0_vliw <= to_unsigned(((1 + MYHDL42_wa(1)) + MYHDL43_wr(1)) + 512, 17);
            execute_vliw0_nextstate <= S_EXEC;
        when S_STORE1 =>
            execute_vliw0_vliw <= to_unsigned(4096, 17);
            execute_vliw0_nextstate <= S_STORE2;
        when S_STORE2 =>
            execute_vliw0_vliw <= to_unsigned((2 + MYHDL44_wr(1)) + 512, 17);
            execute_vliw0_nextstate <= S_EXEC;
        when S_BRANCH_SYNC =>
            if (evt_cache_wait = '0') then
                execute_vliw0_vliw <= to_unsigned(0, 17);
                execute_vliw0_nextstate <= S_EXEC;
            else
                execute_vliw0_vliw <= to_unsigned(4096, 17);
                execute_vliw0_nextstate <= S_BRANCH_SYNC;
            end if;
        when S_SYNC =>
            execute_vliw0_vliw <= to_unsigned(0, 17);
            execute_vliw0_nextstate <= S_EXEC;
        when S_WAIT =>
            execute_vliw0_vliw <= to_unsigned(4096 + MYHDL45_wr(1), 17);
            execute_vliw0_nextstate <= S_SAVEADD;
        when S_SAVEADD =>
            execute_vliw0_vliw <= to_unsigned((MYHDL46_wa(1) + MYHDL47_wr(8)) + 512, 17);
            execute_vliw0_nextstate <= S_EXEC;
        when S_HOLD =>
            execute_vliw0_vliw <= to_unsigned(4096, 17);
            if (execute_vliw0_evt_hold = '0') then
                execute_vliw0_nextstate <= S_EXEC;
            else
                execute_vliw0_nextstate <= S_HOLD;
            end if;
        when S_RESUME =>
            execute_vliw0_vliw <= to_unsigned(0 + MYHDL48_wr(1), 17);
            execute_vliw0_nextstate <= S_EXEC;
        when S_EXC =>
            execute_vliw0_vliw <= to_unsigned(4096, 17);
            if (execute_vliw0_irqlatch = '1') then
                execute_vliw0_nextstate <= S_EXEC;
            else
                execute_vliw0_nextstate <= S_EXC;
            end if;
        when S_IRQ =>
            execute_vliw0_vliw <= to_unsigned((((MYHDL49_newpc(2) + 1) + MYHDL50_wa(1)) + MYHDL51_wr(2)) + 512, 17);
            execute_vliw0_nextstate <= S_BRANCH_SYNC;
        when others =>
            assert False report "ValueError" severity note;
            execute_vliw0_vliw <= to_unsigned(0, 17);
    end case;
end process ZPUNG_EXECUTE_VLIW0_TRANSLATE;

ZPUNG_EXECUTE_VLIW0_PROCEED: process (execute_vliw0_irqlatch, execute_vliw0_idim_save, execute_vliw0_busy, exc, evaddr, sp, imm, execute_vliw0_in_reset, execute_vliw0_evt_dbgbreak, pc, execute_vliw0_in_ucode, execute_vliw0_irqack, execute_vliw0_vliw, spval) is
    variable a: std_logic;
    variable offs: unsigned(4 downto 0);
begin
    execute_vliw0_is_im <= stdl(execute_vliw0_vliw(F_WR_MODE) = 3);
    -- Multiplexing unit for PC advance modes
    if (execute_vliw0_vliw(F_PC_MODE) = 0) then
        execute_vliw0_nextpc <= (pc + 1);
    elsif (execute_vliw0_vliw(F_PC_MODE) = 6) then
        execute_vliw0_nextpc <= resize(unsigned'(to_unsigned(0, 5) & unsigned(imm(5-1 downto 0)) & unsigned'("00000")), 15);
    elsif (execute_vliw0_vliw(F_PC_MODE) = 7) then
        execute_vliw0_nextpc <= spval(15-1 downto 0);
    elsif (execute_vliw0_vliw(F_PC_MODE) = 2) then
        execute_vliw0_nextpc <= resize(evaddr, 15);
    else
        execute_vliw0_nextpc <= pc;
    end if;
    execute_vliw0_evt_cpustat <= unsigned'(execute_vliw0_idim_save & execute_vliw0_evt_dbgbreak & execute_vliw0_irqack & execute_vliw0_irqlatch & execute_vliw0_in_ucode & exc & execute_vliw0_busy & execute_vliw0_in_reset);
    execute_vliw0_sp_push <= (sp - 1);
    execute_vliw0_sp_pop <= (sp + 1);
    a := stdl((not bool(imm(4))));
    offs := unsigned'(a & unsigned(imm(4-1 downto 0)));
    execute_vliw0_offset <= offs;
end process ZPUNG_EXECUTE_VLIW0_PROCEED;

-- Actual execution unit for VLIW instructions
ZPUNG_EXECUTE_VLIW0_WORKER: process (clk) is
    variable wrmode: unsigned(16 downto 0);
    variable a: unsigned(31 downto 0);
begin
    if rising_edge(clk) then
        if (reset = '1') then
            execute_vliw0_acc <= to_unsigned(0, 32);
            execute_vliw0_waddr <= to_unsigned(0, 15);
            sp <= to_unsigned(4222, 15);
            execute_vliw0_in_reset <= '0';
            execute_vliw0_idst1 <= '0';
            execute_vliw0_idst0 <= '0';
            execute_vliw0_write <= '0';
            pc <= to_unsigned(0, 15);
            execute_vliw0_wreg <= to_unsigned(0, 32);
            execute_vliw0_idim <= '0';
        else
            execute_vliw0_idst1 <= execute_vliw0_vliw(11);
            execute_vliw0_idst0 <= stdl((execute_vliw0_vliw(F_WA_MODE) = 1) and bool(execute_vliw0_vliw(9)));
            execute_vliw0_in_reset <= stdl(state = S_RESET);
            if (state = S_RESET) then
                pc <= to_unsigned(0, 15);
            elsif ((execute_vliw0_evt_hold_pc = '0') and ((execute_vliw0_irqlatch = '0') or (execute_vliw0_is_im = '1') or (execute_vliw0_in_exc = '1'))) then
                pc <= execute_vliw0_nextpc;
            elsif (execute_vliw0_vliw(13) = '1') then
                pc <= execute_vliw0_nextpc;
            end if;
            if ((state = S_EXEC) and (execute_vliw0_evt_hold = '0')) then
                execute_vliw0_idim <= execute_vliw0_is_im;
            elsif (state = S_RESUME) then
                execute_vliw0_idim <= execute_vliw0_idim_save;
            elsif (state = S_IRQ) then
                execute_vliw0_idim <= '0';
            end if;
            if bool(execute_vliw0_vliw(0)) then
                if (not bool(execute_vliw0_vliw(1))) then
                    if (0 = 1) then
                        sp <= (sp - 1);
                    else
                        sp <= execute_vliw0_sp_push;
                    end if;
                end if;
            elsif bool(execute_vliw0_vliw(2)) then
                sp <= spval(MEM_ADDR_SLICE);
            elsif bool(execute_vliw0_vliw(1)) then
                if (1 = 1) then
                    sp <= (sp + 1);
                else
                    sp <= execute_vliw0_sp_pop;
                end if;
            end if;
            execute_vliw0_write <= execute_vliw0_vliw(9);
            if ((execute_vliw0_vliw(F_WA_MODE) = 1) and bool(execute_vliw0_vliw(0)) and (not bool(execute_vliw0_vliw(1)))) then
                execute_vliw0_waddr <= (sp - 1);
            elsif (execute_vliw0_vliw(F_WA_MODE) = 1) then
                execute_vliw0_waddr <= sp;
            elsif (execute_vliw0_vliw(F_WA_MODE) = 3) then
                execute_vliw0_waddr <= (sp + execute_vliw0_offset);
            elsif (execute_vliw0_vliw(F_WA_MODE) = 2) then
                execute_vliw0_waddr <= spval(MEM_ADDR_SLICE);
            else
                null;
            end if;
            wrmode := resize(execute_vliw0_vliw(F_WR_MODE), 17);
            a := execute_vliw0_wreg;
            if (wrmode = 3) then
                if bool(execute_vliw0_idim) then
                    execute_vliw0_wreg <= unsigned'(execute_vliw0_wreg((32 - 7)-1 downto 0) & unsigned(imm(7-1 downto 0)));
                else
                    execute_vliw0_wreg <= unsigned(resize(imm, 32));
                end if;
            elsif (wrmode = 2) then
                execute_vliw0_wreg <= resize(pc, 32);
            elsif (wrmode = 1) then
                execute_vliw0_wreg <= spval;
            elsif (wrmode = 4) then
                execute_vliw0_wreg <= resize(unsigned'(to_unsigned(0, 15) & sp & unsigned'("00")), 32);
            elsif (wrmode = 5) then
                execute_vliw0_wreg <= (not spval);
            elsif (wrmode = 6) then
                execute_vliw0_wreg <= MYHDL54_flip(spval);
            elsif (0 = 0) then
                if (wrmode = 10) then
                    execute_vliw0_wreg <= (a or spval);
                elsif (wrmode = 8) then
                    execute_vliw0_wreg <= unsigned(signed(a) + signed(spval));
                elsif (wrmode = 9) then
                    execute_vliw0_wreg <= (a and spval);
                end if;
            elsif (wrmode = 7) then
                execute_vliw0_wreg <= execute_vliw0_acc;
            end if;
            if (0 = 1) then
                if (wrmode = 10) then
                    execute_vliw0_acc <= (execute_vliw0_acc or a);
                elsif (wrmode = 8) then
                    execute_vliw0_acc <= unsigned(signed(execute_vliw0_acc) + signed(a));
                elsif (wrmode = 9) then
                    execute_vliw0_acc <= (execute_vliw0_acc and a);
                end if;
            end if;
        end if;
    end if;
end process ZPUNG_EXECUTE_VLIW0_WORKER;

-- Simple zero latency fetch unit. Slow.
ZPUNG_FETCH0_SELECT: process (fetch0_mod_d, pc, tap_emuir, imem_idata, fetch0_emuexec) is
    variable ir32: unsigned(31 downto 0);
begin
    ir32 := imem_idata;
    if (fetch0_emuexec = '1') then
        insn <= tap_emuir;
    elsif (fetch0_mod_d = 0) then
        insn <= ir32(32-1 downto 24);
    elsif (fetch0_mod_d = 1) then
        insn <= ir32(24-1 downto 16);
    elsif (fetch0_mod_d = 2) then
        insn <= ir32(16-1 downto 8);
    else
        insn <= ir32(8-1 downto 0);
    end if;
    imem_iaddr <= resize(pc(15-1 downto 2), 12);
end process ZPUNG_FETCH0_SELECT;

ZPUNG_FETCH0_PROCEED: process (clk) is
begin
    if rising_edge(clk) then
        fetch0_mod_d <= pc(2-1 downto 0);
    end if;
end process ZPUNG_FETCH0_PROCEED;

-- ZPU instruction abstraction ('legacy interpreter')
ZPUNG_INSTRUCTION_DECODE0_WORKER: process (insn) is
    variable im: signed(7 downto 0);
    variable m: t_enum_t_mode_2;
    variable op: unsigned(7 downto 0);
begin
    m := M_NOP;
    im := resize(signed(insn(7-1 downto 0)), 8);
    func <= resize(insn(OPMODE_GEN), 3);
    if (insn(7) = '1') then
        m := M_IMM;
    elsif (insn(OPMODE_SPLDST) = 1) then
        m := M_EMUINSN;
    elsif (insn(OPMODE_SPLDST) = 3) then
        m := M_LDSP;
    elsif (insn(OPMODE_SPLDST) = 2) then
        m := M_STSP;
    elsif (insn(OPMODE_SPOP) = 1) then
        m := M_ADDSP;
    else
        op := resize(insn(OPMODE_GEN), 8);
        case op is
            when "00000000" =>
                m := M_SWBRK;
            when "00000010" =>
                m := M_PUSHSP;
            when "00000100" =>
                m := M_POPPC;
            when "00000101" =>
                m := M_ALU;
            when "00000111" =>
                m := M_ALU;
            when "00000110" =>
                m := M_ALU;
            when "00001000" =>
                m := M_LOAD;
            when "00001001" =>
                m := M_NOT;
            when "00001010" =>
                m := M_FLIP;
            when "00001100" =>
                m := M_STORE;
            when "00001101" =>
                m := M_POPSP;
            when "00001111" =>
                m := M_REARM;
            when "00000011" =>
                m := M_POPINT;
            when others =>
                m := M_NOP;
        end case;
    end if;
    mode <= m;
    imm <= resize(im, 7);
end process ZPUNG_INSTRUCTION_DECODE0_WORKER;

-- Debug Logic state machine for three pipeline stage CPU types
ZPUNG_DEBUG_LOGIC0_FSM: process (clk, tap_reset) is
begin
    if (tap_reset = '1') then
        fetch0_emuexec <= '0';
        debug_logic0_state <= S_RUN;
        debug_logic0_swbreak <= '0';
        execute_vliw0_evt_toggle_emu <= '0';
    elsif rising_edge(clk) then
        execute_vliw0_evt_toggle_emu <= '0';
        case debug_logic0_state is
            when S_RUN =>
                if ((tap_emureq = '1') or (execute_vliw0_evt_brk = '1')) then
                    if ((not bool(debug_logic0_emumask)) or bool(execute_vliw0_evt_brk)) then
                        debug_logic0_state <= S_EMUACK;
                        execute_vliw0_evt_toggle_emu <= '1';
                    end if;
                    if bool(execute_vliw0_evt_brk) then
                        debug_logic0_swbreak <= '1';
                    end if;
                end if;
            when S_EMUACK =>
                if (debug_logic0_busy = '0') then
                    debug_logic0_state <= S_EMULATION;
                end if;
            when S_RESUME =>
                execute_vliw0_evt_toggle_emu <= '1';
                debug_logic0_state <= S_RUN;
            when S_EMUEXEC =>
                if bool(execute_vliw0_evt_brk) then
                    debug_logic0_state <= S_RESUME;
                    debug_logic0_swbreak <= '0';
                elsif (debug_logic0_busy = '0') then
                    debug_logic0_state <= S_EMUACK;
                end if;
            when others => -- S_EMULATION
                if (execute_vliw0_evt_reset = '1') then
                    debug_logic0_swbreak <= '0';
                end if;
                if (tap_emuexec = '1') then
                    debug_logic0_state <= S_EMUEXEC;
                end if;
        end case;
        fetch0_emuexec <= stdl(bool(tap_emuexec) and (debug_logic0_state = S_EMULATION));
    end if;
end process ZPUNG_DEBUG_LOGIC0_FSM;

ZPUNG_DEBUG_LOGIC0_ASSIGN: process (execute_vliw0_evt_busy, execute_vliw0_evt_cpustat, debug_logic0_state, tap_emumask, tap_emureq, tap_emuexec, debug_logic0_swbreak, execute_vliw0_evt_emumask) is
    variable ack: std_logic;
    variable t: std_logic;
begin
    ack := stdl((debug_logic0_state = S_EMUACK) or (debug_logic0_state = S_EMULATION) or (debug_logic0_state = S_EMUEXEC));
    tap_exstat <= execute_vliw0_evt_cpustat;
    tap_emuack <= ack;
    execute_vliw0_evt_emuack <= ack;
    execute_vliw0_evt_dbgbreak <= debug_logic0_swbreak;
    tap_emurdy <= stdl(debug_logic0_state = S_EMULATION);
    execute_vliw0_evt_hold <= stdl(((debug_logic0_state = S_EMULATION) or (debug_logic0_state = S_EMUACK)) and (not bool(tap_emuexec)));
    t := stdl(bool(execute_vliw0_evt_emumask) and bool(tap_emumask));
    debug_logic0_emumask <= t;
    execute_vliw0_evt_hold_pc <= stdl(bool(tap_emureq) and (not (debug_logic0_state = S_RESUME)) and (not bool(t)));
    debug_logic0_busy <= stdl(bool(execute_vliw0_evt_busy) or bool(t));
end process ZPUNG_DEBUG_LOGIC0_ASSIGN;

ZPUNG_MEMMGR0_SELECT: process (memmgr0_dmem_d, imem_rdata, execute_vliw0_pa_wdata, mmr_busy, memmgr0_iomem_d, memmgr0_sb_rdata, execute_vliw0_pa_we, execute_vliw0_pa_addr, execute_vliw0_pb_addr, mmr_rdata) is
begin
    mmr_wdata <= execute_vliw0_pa_wdata;
    imem_wdata <= execute_vliw0_pa_wdata;
    mmr_addr <= execute_vliw0_pb_addr;
    imem_daddr <= execute_vliw0_pb_addr((14 - 2)-1 downto 0);
    iobusy <= mmr_busy;
    if (MYHDL63_is_mmr(execute_vliw0_pb_addr) = '1') then
        mmr_re <= '1';
        imem_read <= '0';
    elsif (MYHDL64_is_dmem(execute_vliw0_pb_addr) = '1') then
        imem_read <= '1';
        mmr_re <= '0';
    else
        imem_read <= '0';
        mmr_re <= '0';
    end if;
    if (MYHDL65_is_mmr(execute_vliw0_pa_addr) = '1') then
        imem_write <= '0';
        mmr_we <= execute_vliw0_pa_we;
        if (execute_vliw0_pa_we = '1') then
            mmr_addr <= execute_vliw0_pa_addr;
        end if;
        memmgr0_sa_we <= '0';
    elsif (MYHDL66_is_dmem(execute_vliw0_pa_addr) = '1') then
        imem_write <= execute_vliw0_pa_we;
        mmr_we <= '0';
        if (execute_vliw0_pa_we = '1') then
            imem_daddr <= resize(execute_vliw0_pa_addr((17 - 2)-1 downto 0), 12);
        end if;
        memmgr0_sa_we <= '0';
    else
        imem_write <= '0';
        mmr_we <= '0';
        memmgr0_sa_we <= execute_vliw0_pa_we;
    end if;
    if (memmgr0_iomem_d = '1') then
        execute_vliw0_pb_rdata <= mmr_rdata;
    elsif (memmgr0_dmem_d = '1') then
        execute_vliw0_pb_rdata <= imem_rdata;
    else
        execute_vliw0_pb_rdata <= memmgr0_sb_rdata;
    end if;
    memmgr0_sa_addr <= execute_vliw0_pa_addr(9-1 downto 0);
    memmgr0_sa_wdata <= execute_vliw0_pa_wdata;
    memmgr0_sb_addr <= execute_vliw0_pb_addr(9-1 downto 0);
end process ZPUNG_MEMMGR0_SELECT;

ZPUNG_MEMMGR0_STACKMEM0_WORK: process (clk) is
begin
    if rising_edge(clk) then
        if ((memmgr0_sa_we = '1') and (memmgr0_sa_addr = memmgr0_sb_addr)) then
            memmgr0_stackmem0_data <= memmgr0_sa_wdata;
        else
            memmgr0_stackmem0_data <= memmgr0_stackmem0_ram(to_integer(memmgr0_sb_addr));
        end if;
        if (memmgr0_sa_we = '1') then
            
            memmgr0_stackmem0_ram(to_integer(memmgr0_sa_addr)) <= memmgr0_sa_wdata;
        end if;
    end if;
end process ZPUNG_MEMMGR0_STACKMEM0_WORK;


memmgr0_sb_rdata <= memmgr0_stackmem0_data;

ZPUNG_MEMMGR0_LDDELAY: process (clk) is
begin
    if rising_edge(clk) then
        memmgr0_dmem_d <= MYHDL70_is_dmem(execute_vliw0_pb_addr);
        if (iobusy = '0') then
            memmgr0_iomem_d <= MYHDL71_is_mmr(execute_vliw0_pb_addr);
        end if;
    end if;
end process ZPUNG_MEMMGR0_LDDELAY;


tap_curpc <= resize(pc, 32);
tap_odata <= spval;
evt_override <= override;
evt_cache_wait <= cache_wait;

end architecture MyHDL;
