-- File: ZPUng.vhd
-- Generated by MyHDL 0.9dev
-- Date: Mon Oct 22 18:10:13 2018


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_09.all;

entity ZPUng is
    port (
        clk: in std_logic;
        reset: in std_logic;
        irq: in std_logic;
        override: in std_logic;
        exc: in std_logic;
        cache_wait: in std_logic;
        evaddr: in unsigned(13 downto 0);
        tap_reset: in std_logic;
        tap_emumask: in std_logic;
        tap_exstat: out unsigned(7 downto 0);
        tap_idata: in unsigned(31 downto 0);
        tap_emuexec: in std_logic;
        tap_odata: out unsigned(31 downto 0);
        tap_emuir: in unsigned(7 downto 0);
        tap_emuack: out std_logic;
        tap_emurdy: out std_logic;
        tap_curpc: out unsigned(31 downto 0);
        tap_emureq: in std_logic;
        mmr_we: out std_logic;
        mmr_busy: in std_logic;
        mmr_addr: out unsigned(14 downto 0);
        mmr_re: out std_logic;
        mmr_wdata: out unsigned(31 downto 0);
        mmr_rdata: in unsigned(31 downto 0);
        imem_write: out std_logic;
        imem_idata: in unsigned(31 downto 0);
        imem_read: out std_logic;
        imem_daddr: out unsigned(11 downto 0);
        imem_wdata: out unsigned(31 downto 0);
        imem_rdata: in unsigned(31 downto 0);
        imem_iaddr: out unsigned(11 downto 0)
    );
end entity ZPUng;
-- Variant: v0.1 'legacy small'
--       - ZPUv4 opcode compatible
--       - Regress test zpu-elf-gcc 3.4.2 PASSED
-- 
--            (c) 2013-2015, <hackfin@section5.ch>
-- 
--       THIS VARIANT IS RELEASED ONLY FOR EVALUATION PURPOSES.
--           Contact author for licensing details.
--          
--           Configuration:
--           - Separate Stack and PROG/DATA memory
--           - No prefetch stage (slow)
--           - ZPU 8 bit opcode translation
--           - Simple Load/Store delays
--           - Shortcut and hazard resolving
--           - StdTAP debug v0 (simple) interface enabled
-- 
-- #CONFIG_BARRELSHIFTER is not set
-- #CONFIG_FLIX_UCODE is not set
-- #CONFIG_COTTONPICKEN is not set
--         

architecture MyHDL of ZPUng is


constant OP_ADDSP: integer := 1;
constant USE_ALU_DELAY: integer := 0;
constant PC_INITADDR: integer := 0;
constant CONFIG_SP_POP_DUP: integer := 1;
constant STACKMEM_WIDTH: integer := 9;
constant HAZ_ST1: integer := 2**11;
constant PC_MODE_EVT: integer := 2;
subtype OPMODE_SPOP is integer range 8-1 downto 4;
constant OP_CUSTOM_POPINT: integer := 2**4-1;
constant OP_FLIP: integer := 10;
constant USE_SHORTCUT: integer := 1;
constant UCODE_EMU_WINDOW: integer := 2**10;
constant F_HAZ_ST1: integer := 11;
constant F_SP_PUSH: integer := 0;
constant OP_NOT: integer := 9;
constant IO_WRITE: integer := 2**9;
constant F_PC_MODE0: integer := 12;
constant F_SP_POP: integer := 1;
constant F_IO_LOAD: integer := 10;
constant OP_LOAD: integer := 8;
constant WA_INDIR: integer := 2;
subtype F_WA_MODE is integer range 5-1 downto 3;
constant MMR_BIT_S2: integer := 14;
constant F_PC_JMP: integer := 13;
constant WR_PC: integer := 2;
constant WA_OFFS: integer := 3;
constant WR_AND: integer := 9;
constant OP_POPSP: integer := 13;
constant OP_EMULATE: integer := 1;
constant SPMEM_BIT_S2: integer := 12;
constant SP_POPSP: integer := 4;
constant PC_MODE_JMP: integer := 6;
constant PC_MODE_INC: integer := 0;
subtype MEM_ADDR_SLICE is integer range 17-1 downto 2;
constant F_IRQ_UNLK: integer := 2**4;
constant WR_ADD: integer := 8;
constant OP_LOADSP: integer := 3;
constant WR_NOT: integer := 5;
constant OP_STORESP: integer := 2;
constant CONFIG_SP_PUSH_DUP: integer := 0;
constant MEM_W: integer := 14;
constant WR_FLIP: integer := 6;
constant OP_STORE: integer := 12;
constant OP_BREAK: integer := 0;
constant F_WR_MODE0: integer := 5;
constant OP_ADD: integer := 5;
constant WR_OR: integer := 10;
constant WR_PUSHSP: integer := 4;
constant F_SP_POPSP: integer := 2;
constant PC_INC: integer := 0;
constant WR_ACC: integer := 7;
constant WR_SPVAL: integer := 1;
constant WR_IM: integer := 3;
constant SP_PUSH: integer := 1;
constant IO_LOAD: integer := 2**10;
constant SP_PP: integer := 3;
subtype OPMODE_GEN is integer range 4-1 downto 0;
constant ADDR_W: integer := 17;
constant OP_POPPC: integer := 4;
constant SP_POP: integer := 2;
constant OPMODE_IM: integer := 7;
subtype F_PC_MODE is integer range 15-1 downto 12;
constant F_ALU: integer := 8;
constant WA_SP: integer := 1;
constant F_PC_ISBRANCH: integer := 14;
constant EVT_DEBUG: integer := 2**15;
constant PC_HOLD: integer := 2**12;
constant F_IO_WRITE: integer := 9;
constant PC_MODE_RET: integer := 7;
constant OP_AND: integer := 6;
constant OP_OR: integer := 7;
constant OP_PUSHSP: integer := 2;
subtype F_WR_MODE is integer range 9-1 downto 5;
subtype OPMODE_SPLDST is integer range 8-1 downto 5;
constant F_EVT_DEBUG: integer := 2**4-1;
constant x: integer := 3;
constant IRQ_UNLK: integer := 2**16;
constant F_WA_MODE0: integer := 3;


type t_enum_dbg_state_3 is (
    S_RUN,
    S_RESUME,
    S_EMUACK,
    S_EMULATION,
    S_EMUEXEC
);
type t_enum_t_mode_2 is (
    M_NOP,
    M_IMM,
    M_EMUINSN,
    M_LDSP,
    M_STSP,
    M_ADDSP,
    M_SWBRK,
    M_PUSHSP,
    M_POPPC,
    M_ALU,
    M_LOAD,
    M_NOT,
    M_FLIP,
    M_STORE,
    M_POPSP,
    M_POPINT
);
type t_enum_x_state_1 is (
    S_RESET,
    S_ILLEGAL,
    S_IDLE,
    S_EXEC,
    S_IRQ,
    S_EXC,
    S_HOLD,
    S_RESUME,
    S_ALU,
    S_ALU1,
    S_ALU2,
    S_SYNC,
    S_BRANCH_SYNC,
    S_SAVE,
    S_WAIT,
    S_SAVEADD,
    S_LOAD,
    S_LOAD1,
    S_STORE1,
    S_STORE2
);

signal evt_cache_wait: std_logic;
signal iobusy: std_logic;
signal imm: signed (6 downto 0);
signal pc: unsigned(14 downto 0);
signal state: t_enum_x_state_1;
signal branch: std_logic;
signal insn: unsigned(7 downto 0);
signal evt_override: std_logic;
signal func: unsigned(2 downto 0);
signal sp: unsigned(14 downto 0);
signal mode: t_enum_t_mode_2;
signal spval: unsigned(31 downto 0);
signal inst_memmgr_sb_addr: unsigned(8 downto 0);
signal inst_memmgr_sa_addr: unsigned(8 downto 0);
signal inst_memmgr_pa_wdata: unsigned(31 downto 0);
signal inst_memmgr_iomem_d: std_logic;
signal inst_memmgr_pa_we: std_logic;
signal inst_memmgr_pb_addr: unsigned(14 downto 0);
signal inst_memmgr_sb_rdata: unsigned(31 downto 0);
signal inst_memmgr_pa_addr: unsigned(14 downto 0);
signal inst_memmgr_sa_we: std_logic;
signal inst_memmgr_pb_rdata: unsigned(31 downto 0);
signal inst_memmgr_dmem_d: std_logic;
signal inst_memmgr_sa_wdata: unsigned(31 downto 0);
signal inst_memmgr_inst_stack_data: unsigned(31 downto 0);
signal inst_debug_evt_brk: std_logic;
signal inst_debug_evt_emuexec: std_logic;
signal inst_debug_swbreak: std_logic;
signal inst_debug_evt_dbgbreak: std_logic;
signal inst_debug_busy: std_logic;
signal inst_debug_evt_hold_pc: std_logic;
signal inst_debug_evt_busy: std_logic;
signal inst_debug_state: t_enum_dbg_state_3;
signal inst_debug_evt_toggle_emu: std_logic;
signal inst_debug_evt_cpustat: unsigned(7 downto 0);
signal inst_debug_evt_hold: std_logic;
signal inst_debug_evt_emuack: std_logic;
signal inst_debug_evt_emumask: std_logic;
signal inst_debug_emumask: std_logic;
signal inst_debug_evt_reset: std_logic;
signal inst_exec_in_exc: std_logic;
signal inst_exec_wreg: unsigned(31 downto 0);
signal inst_exec_sp_pop: unsigned(14 downto 0);
signal inst_exec_irqprio: std_logic;
signal inst_exec_in_reset: std_logic;
signal inst_exec_idst0: std_logic;
signal inst_exec_in_ucode: std_logic;
signal inst_exec_irqack: std_logic;
signal inst_exec_is_im: std_logic;
signal inst_exec_ptr: unsigned(14 downto 0);
signal inst_exec_idim_save: std_logic;
signal inst_exec_waddr: unsigned(14 downto 0);
signal inst_exec_shortcut: std_logic;
signal inst_exec_will_branch: std_logic;
signal inst_exec_idim: std_logic;
signal inst_exec_sp_push: unsigned(14 downto 0);
signal inst_exec_aluop: unsigned(2 downto 0);
signal inst_exec_acc: unsigned(31 downto 0);
signal inst_exec_nextpc: unsigned(14 downto 0);
signal inst_exec_busy: std_logic;
signal inst_exec_idst1: std_logic;
signal inst_exec_nextstate: t_enum_x_state_1;
signal inst_exec_irqlatch: std_logic;
signal inst_exec_write: std_logic;
signal inst_exec_vliw: unsigned(16 downto 0);
signal inst_exec_offset: unsigned(4 downto 0);
signal inst_fetch_mod_d: unsigned(1 downto 0);
type t_array_inst_memmgr_inst_stack_ram is array(0 to 512-1) of unsigned(31 downto 0);
signal inst_memmgr_inst_stack_ram: t_array_inst_memmgr_inst_stack_ram;

function MYHDL5_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL5_wr;

function MYHDL6_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL6_wa;

function MYHDL7_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL7_wa;

function MYHDL8_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL8_wr;

function MYHDL9_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL9_wa;

function MYHDL10_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL10_wr;

function MYHDL11_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL11_wa;

function MYHDL12_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL12_wa;

function MYHDL13_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL13_wr;

function MYHDL14_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL14_wa;

function MYHDL15_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL15_wr;

function MYHDL16_newpc(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_PC_MODE0));
end function MYHDL16_newpc;

function MYHDL17_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL17_wa;

function MYHDL18_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL18_wr;

function MYHDL19_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL19_wa;

function MYHDL20_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL20_wr;

function MYHDL21_newpc(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_PC_MODE0));
end function MYHDL21_newpc;

function MYHDL22_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL22_wr;

function MYHDL23_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL23_wa;

function MYHDL24_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL24_wa;

function MYHDL25_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL25_wr;

function MYHDL26_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL26_wa;

function MYHDL27_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL27_wr;

function MYHDL28_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL28_wa;

function MYHDL29_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL29_wr;

function MYHDL30_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL30_wa;

function MYHDL31_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL31_wa;

function MYHDL32_wr(
    x: in integer
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL32_wr;

function MYHDL33_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL33_wr;

function MYHDL34_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL34_wa;

function MYHDL35_wr(
    x: in integer
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL35_wr;

function MYHDL36_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL36_wr;

function MYHDL37_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL37_wa;

function MYHDL38_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL38_wr;

function MYHDL39_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL39_wr;

function MYHDL40_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL40_wa;

function MYHDL41_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL41_wa;

function MYHDL42_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL42_wr;

function MYHDL43_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL43_wr;

function MYHDL44_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL44_wr;

function MYHDL45_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL45_wa;

function MYHDL46_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL46_wr;

function MYHDL47_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL47_wr;

function MYHDL48_newpc(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_PC_MODE0));
end function MYHDL48_newpc;

function MYHDL49_wa(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WA_MODE0));
end function MYHDL49_wa;

function MYHDL50_wr(
    x: in natural
    ) return integer is
begin
    return (x * (2 ** F_WR_MODE0));
end function MYHDL50_wr;

function MYHDL53_flip(
    a: in unsigned
    ) return unsigned is
    variable b: unsigned(31 downto 0);
    variable l: natural;
begin
    l := 32;
    b := a;
    for i in 0 to l-1 loop
        b(i) := a(((l - i) - 1));
    end loop;
    return b;
end function MYHDL53_flip;

function MYHDL62_is_mmr(
    addr: in unsigned
    ) return std_logic is
begin
    if bool(addr(MMR_BIT_S2)) then
        return '1';
    else
        return '0';
    end if;
end function MYHDL62_is_mmr;

function MYHDL63_is_dmem(
    addr: in unsigned
    ) return std_logic is
begin
    if ((addr(SPMEM_BIT_S2) = '0') or (addr(MMR_BIT_S2-1 downto (SPMEM_BIT_S2 + 1)) /= 0)) then
        return '1';
    else
        return '0';
    end if;
end function MYHDL63_is_dmem;

function MYHDL64_is_mmr(
    addr: in unsigned
    ) return std_logic is
begin
    if bool(addr(MMR_BIT_S2)) then
        return '1';
    else
        return '0';
    end if;
end function MYHDL64_is_mmr;

function MYHDL65_is_dmem(
    addr: in unsigned
    ) return std_logic is
begin
    if ((addr(SPMEM_BIT_S2) = '0') or (addr(MMR_BIT_S2-1 downto (SPMEM_BIT_S2 + 1)) /= 0)) then
        return '1';
    else
        return '0';
    end if;
end function MYHDL65_is_dmem;

function MYHDL69_is_dmem(
    addr: in unsigned
    ) return std_logic is
begin
    if ((addr(SPMEM_BIT_S2) = '0') or (addr(MMR_BIT_S2-1 downto (SPMEM_BIT_S2 + 1)) /= 0)) then
        return '1';
    else
        return '0';
    end if;
end function MYHDL69_is_dmem;

function MYHDL70_is_mmr(
    addr: in unsigned
    ) return std_logic is
begin
    if bool(addr(MMR_BIT_S2)) then
        return '1';
    else
        return '0';
    end if;
end function MYHDL70_is_mmr;

begin




ZPUNG_INST_EXEC_SELECT: process (reset, inst_exec_wreg, inst_exec_sp_pop, sp, inst_memmgr_pb_rdata, inst_exec_idst1, inst_exec_idst0, state, inst_exec_nextpc, inst_exec_offset, inst_exec_vliw) is
    variable b: std_logic;
    variable is_in_ucode: std_logic;
    variable bypass: natural;
begin
    bypass := 0;
    inst_exec_shortcut <= '0';
    inst_exec_ptr <= sp;
    inst_exec_will_branch <= inst_exec_vliw(F_PC_ISBRANCH);
    inst_debug_evt_reset <= reset;
    inst_debug_evt_brk <= inst_exec_vliw(F_EVT_DEBUG);
    is_in_ucode := stdl(inst_exec_nextpc < UCODE_EMU_WINDOW);
    inst_exec_in_ucode <= is_in_ucode;
    b := stdl((state /= S_EXEC) and (state /= S_HOLD));
    inst_exec_busy <= stdl(state = S_LOAD);
    inst_debug_evt_busy <= b;
    inst_debug_evt_emumask <= is_in_ucode;
    if (state = S_STORE2) then
        inst_exec_ptr <= inst_exec_sp_pop;
    elsif (state = S_EXEC) then
        if (inst_exec_vliw(F_SP_POP) = '1') then
            inst_exec_ptr <= inst_exec_sp_pop;
            if bool(inst_exec_idst0) then
                inst_exec_shortcut <= stdl(USE_SHORTCUT);
                bypass := USE_SHORTCUT;
            elsif bool(inst_exec_idst1) then
                bypass := USE_SHORTCUT;
            end if;
        elsif (bool(inst_exec_vliw(F_SP_PUSH)) and (inst_exec_vliw(F_WR_MODE) = WR_SPVAL)) then
            if ((inst_exec_idst0 = '1') or (inst_exec_idst1 = '1')) then
                inst_exec_shortcut <= stdl(USE_SHORTCUT);
                bypass := USE_SHORTCUT;
            end if;
        elsif (inst_exec_vliw(F_WA_MODE) = WA_OFFS) then
            inst_exec_ptr <= (sp + inst_exec_offset);
        end if;
    end if;
    if bool(bypass) then
        spval <= inst_exec_wreg;
    else
        spval <= inst_memmgr_pb_rdata;
    end if;
end process ZPUNG_INST_EXEC_SELECT;

-- Address muxing
ZPUNG_INST_EXEC_ADDRMUX: process (inst_exec_waddr, inst_exec_idst1, inst_exec_write, inst_exec_wreg, inst_exec_vliw, spval, inst_exec_ptr) is
begin
    if bool(inst_exec_vliw(F_IO_LOAD)) then
        inst_memmgr_pb_addr <= spval(MEM_ADDR_SLICE);
    else
        inst_memmgr_pb_addr <= inst_exec_ptr;
    end if;
    inst_memmgr_pa_addr <= inst_exec_waddr;
    inst_memmgr_pa_we <= inst_exec_write;
    if ((inst_exec_vliw(F_HAZ_ST1) = '1') and (inst_exec_idst1 = '1')) then
        inst_memmgr_pa_wdata <= spval;
    else
        inst_memmgr_pa_wdata <= inst_exec_wreg;
    end if;
end process ZPUNG_INST_EXEC_ADDRMUX;

-- State machine. VERY UGLY. There are many priorities to sort out.
-- Therefore it may be as ugly as the Linux scheduler...
ZPUNG_INST_EXEC_FSM: process (clk) is
    variable can_interrupt: std_logic;
begin
    if rising_edge(clk) then
        inst_exec_aluop <= (func - OP_ADD);
        branch <= inst_exec_will_branch;
        if (inst_debug_evt_toggle_emu = '1') then
            inst_exec_idim_save <= inst_exec_idim;
        end if;
        if (inst_exec_irqack = '1') then
            if (evt_override = '1') then
                inst_exec_irqack <= '0';
                inst_exec_irqprio <= '1';
            end if;
            if (inst_exec_vliw(F_IRQ_UNLK) = '1') then
                if (inst_exec_irqprio = '0') then
                    inst_exec_irqack <= '0';
                else
                    inst_exec_irqprio <= '0';
                end if;
            end if;
            inst_exec_irqlatch <= '0';
        elsif ((state = S_EXEC) or (state = S_EXC)) then
            if ((inst_debug_evt_emuack = '0') and (inst_exec_will_branch = '0')) then
                inst_exec_irqlatch <= irq;
            end if;
        end if;
        inst_exec_in_exc <= exc;
        can_interrupt := stdl(((inst_exec_irqlatch = '1') and (inst_exec_irqack = '0') and (inst_exec_is_im = '0')) and (inst_debug_evt_emuack = '0'));
        if (reset = '1') then
            state <= S_RESET;
            inst_exec_idim_save <= '0';
            inst_exec_in_exc <= '0';
            inst_exec_irqprio <= '0';
            inst_exec_irqack <= '0';
            inst_exec_irqlatch <= '0';
        elsif ((exc = '1') and (inst_exec_in_exc = '0')) then
            state <= S_EXC;
        elsif ((inst_exec_nextstate = S_EXEC) and (can_interrupt = '1')) then
            inst_exec_irqack <= '1';
            state <= S_IRQ;
        elsif bool(inst_exec_shortcut) then
            if (inst_exec_vliw(F_WA_MODE) = WA_INDIR) then
                state <= S_STORE2;
            elsif (mode = M_ALU) then
                state <= S_ALU1;
            elsif (mode = M_POPPC) then
                state <= inst_exec_nextstate;
            elsif (mode = M_IMM) then
                null;
            elsif (mode = M_POPINT) then
                state <= inst_exec_nextstate;
            elsif (mode = M_POPSP) then
                state <= inst_exec_nextstate;
            elsif (mode = M_EMUINSN) then
                null;
            elsif (mode = M_FLIP) then
                null;
            elsif (mode = M_NOT) then
                null;
            elsif (mode = M_STSP) then
                null;
            elsif (mode = M_ADDSP) then
                state <= inst_exec_nextstate;
            elsif (mode = M_LDSP) then
                state <= inst_exec_nextstate;
            elsif (mode = M_LOAD) then
                state <= inst_exec_nextstate;
            else
                assert False report "End of Simulation" severity Failure;
            end if;
        else
            state <= inst_exec_nextstate;
        end if;
    end if;
end process ZPUNG_INST_EXEC_FSM;

-- Translate ZPU instruction to VLIW
ZPUNG_INST_EXEC_TRANSLATE: process (mode, state, inst_exec_offset, inst_exec_aluop, inst_exec_idim, inst_exec_idst0, inst_debug_evt_hold, inst_debug_evt_emuack, evt_cache_wait, iobusy, inst_exec_irqlatch) is
    variable stspflags: integer;
    variable f: integer;
begin
    inst_exec_vliw <= to_unsigned(PC_INC, 17);
    inst_exec_nextstate <= S_ILLEGAL;
    case state is
        when S_RESET =>
            inst_exec_nextstate <= S_EXEC;
        when S_EXEC =>
            if (inst_debug_evt_hold = '1') then
                inst_exec_nextstate <= S_HOLD;
                inst_exec_vliw <= to_unsigned(PC_HOLD, 17);
            elsif (mode = M_IMM) then
                f := ((MYHDL5_wr(WR_IM) + MYHDL6_wa(WA_SP)) + IO_WRITE);
                if bool(inst_exec_idim) then
                    inst_exec_vliw <= to_unsigned(f, 17);
                else
                    inst_exec_vliw <= to_unsigned(f + SP_PUSH, 17);
                end if;
                inst_exec_nextstate <= S_EXEC;
            elsif (mode = M_STSP) then
                stspflags := (((SP_POP + MYHDL7_wa(WA_OFFS)) + MYHDL8_wr(WR_SPVAL)) + IO_WRITE);
                if (inst_exec_offset = 1) then
                    inst_exec_vliw <= to_unsigned(stspflags + HAZ_ST1, 17);
                else
                    inst_exec_vliw <= to_unsigned(stspflags, 17);
                end if;
                inst_exec_nextstate <= S_EXEC;
            elsif (mode = M_LDSP) then
                if ((inst_exec_offset = 0) and (inst_exec_idst0 = '1')) then
                    inst_exec_nextstate <= S_EXEC;
                    inst_exec_vliw <= to_unsigned(((SP_PUSH + MYHDL9_wa(WA_SP)) + MYHDL10_wr(WR_SPVAL)) + IO_WRITE, 17);
                else
                    inst_exec_nextstate <= S_SAVE;
                    inst_exec_vliw <= to_unsigned(PC_HOLD + MYHDL11_wa(WA_OFFS), 17);
                end if;
            elsif (mode = M_ADDSP) then
                if ((inst_exec_offset = 0) and (inst_exec_idst0 = '1')) then
                    inst_exec_vliw <= to_unsigned(((SP_PP + MYHDL12_wa(WA_SP)) + MYHDL13_wr(WR_ADD)) + IO_WRITE, 17);
                    inst_exec_nextstate <= S_EXEC;
                else
                    inst_exec_vliw <= to_unsigned((PC_HOLD + MYHDL14_wa(WA_OFFS)) + MYHDL15_wr(WR_SPVAL), 17);
                    inst_exec_nextstate <= S_WAIT;
                end if;
            elsif (mode = M_EMUINSN) then
                inst_exec_vliw <= to_unsigned((((MYHDL16_newpc(PC_MODE_JMP) + SP_PUSH) + MYHDL17_wa(WA_SP)) + MYHDL18_wr(WR_PC)) + IO_WRITE, 17);
                inst_exec_nextstate <= S_BRANCH_SYNC;
            elsif (mode = M_PUSHSP) then
                inst_exec_vliw <= to_unsigned(((SP_PUSH + MYHDL19_wa(WA_SP)) + MYHDL20_wr(WR_PUSHSP)) + IO_WRITE, 17);
                inst_exec_nextstate <= S_EXEC;
            elsif (mode = M_POPPC) then
                inst_exec_vliw <= to_unsigned(MYHDL21_newpc(PC_MODE_RET) + SP_POP, 17);
                inst_exec_nextstate <= S_BRANCH_SYNC;
            elsif (mode = M_ALU) then
                inst_exec_vliw <= to_unsigned((PC_HOLD + SP_POP) + MYHDL22_wr(WR_SPVAL), 17);
                inst_exec_nextstate <= S_ALU1;
            elsif (mode = M_LOAD) then
                inst_exec_vliw <= to_unsigned(((PC_HOLD + SP_PP) + MYHDL23_wa(WA_SP)) + IO_LOAD, 17);
                inst_exec_nextstate <= S_LOAD;
            elsif (mode = M_NOT) then
                inst_exec_vliw <= to_unsigned(((SP_PP + MYHDL24_wa(WA_SP)) + MYHDL25_wr(WR_NOT)) + IO_WRITE, 17);
                inst_exec_nextstate <= S_EXEC;
            elsif (mode = M_FLIP) then
                inst_exec_vliw <= to_unsigned(((SP_PP + MYHDL26_wa(WA_SP)) + MYHDL27_wr(WR_FLIP)) + IO_WRITE, 17);
                inst_exec_nextstate <= S_EXEC;
            elsif (mode = M_STORE) then
                inst_exec_vliw <= to_unsigned(((PC_HOLD + SP_POP) + MYHDL28_wa(WA_INDIR)) + MYHDL29_wr(WR_SPVAL), 17);
                inst_exec_nextstate <= S_STORE1;
            elsif (mode = M_POPSP) then
                inst_exec_vliw <= to_unsigned(((PC_HOLD + SP_POP) + SP_POPSP) + MYHDL30_wa(WA_SP), 17);
                inst_exec_nextstate <= S_SYNC;
            elsif (mode = M_POPINT) then
                inst_exec_vliw <= to_unsigned(IRQ_UNLK, 17);
                inst_exec_nextstate <= S_EXEC;
            elsif (mode = M_NOP) then
                inst_exec_nextstate <= S_EXEC;
            elsif (mode = M_SWBRK) then
                inst_exec_vliw <= to_unsigned(PC_HOLD + EVT_DEBUG, 17);
                if (inst_debug_evt_emuack = '1') then
                    inst_exec_nextstate <= S_RESUME;
                else
                    inst_exec_nextstate <= S_EXEC;
                end if;
            else
                inst_exec_vliw <= to_unsigned(PC_INC, 17);
            end if;
        when S_ALU1 =>
            if (USE_ALU_DELAY = 1) then
                inst_exec_vliw <= to_unsigned((MYHDL31_wa(WA_SP) + MYHDL32_wr(to_integer(inst_exec_aluop))) + MYHDL33_wr(F_ALU), 17);
                inst_exec_nextstate <= S_ALU2;
            else
                inst_exec_vliw <= to_unsigned(((MYHDL34_wa(WA_SP) + MYHDL35_wr(to_integer(inst_exec_aluop))) + MYHDL36_wr(F_ALU)) + IO_WRITE, 17);
                inst_exec_nextstate <= S_EXEC;
            end if;
        when S_ALU2 =>
            inst_exec_vliw <= to_unsigned((MYHDL37_wa(WA_SP) + MYHDL38_wr(WR_ACC)) + IO_WRITE, 17);
            inst_exec_nextstate <= S_EXEC;
        when S_LOAD =>
            inst_exec_vliw <= to_unsigned(PC_HOLD + MYHDL39_wr(WR_SPVAL), 17);
            if (iobusy = '1') then
                inst_exec_nextstate <= S_LOAD;
            else
                inst_exec_nextstate <= S_LOAD1;
            end if;
        when S_LOAD1 =>
            inst_exec_vliw <= to_unsigned(MYHDL40_wa(WA_SP) + IO_WRITE, 17);
            inst_exec_nextstate <= S_EXEC;
        when S_SAVE =>
            inst_exec_vliw <= to_unsigned(((SP_PUSH + MYHDL41_wa(WA_SP)) + MYHDL42_wr(WR_SPVAL)) + IO_WRITE, 17);
            inst_exec_nextstate <= S_EXEC;
        when S_STORE1 =>
            inst_exec_vliw <= to_unsigned(PC_HOLD, 17);
            inst_exec_nextstate <= S_STORE2;
        when S_STORE2 =>
            inst_exec_vliw <= to_unsigned((SP_POP + MYHDL43_wr(WR_SPVAL)) + IO_WRITE, 17);
            inst_exec_nextstate <= S_EXEC;
        when S_BRANCH_SYNC =>
            if (evt_cache_wait = '0') then
                inst_exec_vliw <= to_unsigned(PC_INC, 17);
                inst_exec_nextstate <= S_EXEC;
            else
                inst_exec_vliw <= to_unsigned(PC_HOLD, 17);
                inst_exec_nextstate <= S_BRANCH_SYNC;
            end if;
        when S_SYNC =>
            inst_exec_vliw <= to_unsigned(PC_INC, 17);
            inst_exec_nextstate <= S_EXEC;
        when S_WAIT =>
            inst_exec_vliw <= to_unsigned(PC_HOLD + MYHDL44_wr(WR_SPVAL), 17);
            inst_exec_nextstate <= S_SAVEADD;
        when S_SAVEADD =>
            inst_exec_vliw <= to_unsigned((MYHDL45_wa(WA_SP) + MYHDL46_wr(WR_ADD)) + IO_WRITE, 17);
            inst_exec_nextstate <= S_EXEC;
        when S_HOLD =>
            inst_exec_vliw <= to_unsigned(PC_HOLD, 17);
            if (inst_debug_evt_hold = '0') then
                inst_exec_nextstate <= S_EXEC;
            else
                inst_exec_nextstate <= S_HOLD;
            end if;
        when S_RESUME =>
            inst_exec_vliw <= to_unsigned(PC_INC + MYHDL47_wr(WR_SPVAL), 17);
            inst_exec_nextstate <= S_EXEC;
        when S_EXC =>
            inst_exec_vliw <= to_unsigned(PC_HOLD, 17);
            if (inst_exec_irqlatch = '1') then
                inst_exec_nextstate <= S_EXEC;
            else
                inst_exec_nextstate <= S_EXC;
            end if;
        when S_IRQ =>
            inst_exec_vliw <= to_unsigned((((MYHDL48_newpc(PC_MODE_EVT) + SP_PUSH) + MYHDL49_wa(WA_SP)) + MYHDL50_wr(WR_PC)) + IO_WRITE, 17);
            inst_exec_nextstate <= S_BRANCH_SYNC;
        when others =>
            assert False report "End of Simulation" severity Failure;
            inst_exec_vliw <= to_unsigned(PC_INC, 17);
    end case;
end process ZPUNG_INST_EXEC_TRANSLATE;


ZPUNG_INST_EXEC_PROCEED: process (inst_debug_evt_dbgbreak, inst_exec_idim_save, inst_exec_busy, exc, evaddr, sp, imm, inst_exec_in_reset, inst_exec_irqlatch, pc, inst_exec_in_ucode, inst_exec_irqack, inst_exec_vliw, spval) is
    variable a: std_logic;
    variable offs: unsigned(4 downto 0);
begin
    inst_exec_is_im <= stdl(inst_exec_vliw(F_WR_MODE) = WR_IM);
    -- Multiplexing unit for PC advance modes
    if (inst_exec_vliw(F_PC_MODE) = PC_MODE_INC) then
        inst_exec_nextpc <= (pc + 1);
    elsif (inst_exec_vliw(F_PC_MODE) = PC_MODE_JMP) then
        inst_exec_nextpc <= unsigned'(to_unsigned(0, 5) & unsigned(imm(5-1 downto 0)) & unsigned'("00000"));
    elsif (inst_exec_vliw(F_PC_MODE) = PC_MODE_RET) then
        inst_exec_nextpc <= spval(15-1 downto 0);
    elsif (inst_exec_vliw(F_PC_MODE) = PC_MODE_EVT) then
        inst_exec_nextpc <= resize(evaddr, 15);
    else
        inst_exec_nextpc <= pc;
    end if;
    inst_debug_evt_cpustat <= unsigned'(inst_exec_idim_save & inst_debug_evt_dbgbreak & inst_exec_irqack & inst_exec_irqlatch & inst_exec_in_ucode & exc & inst_exec_busy & inst_exec_in_reset);
    inst_exec_sp_push <= (sp - 1);
    inst_exec_sp_pop <= (sp + 1);
    a := stdl((not bool(imm(4))));
    offs := unsigned'(a & unsigned(imm(4-1 downto 0)));
    inst_exec_offset <= offs;
end process ZPUNG_INST_EXEC_PROCEED;

-- Actual execution unit for VLIW instructions
ZPUNG_INST_EXEC_WORKER: process (clk) is
    variable wrmode: unsigned(16 downto 0);
    variable a: unsigned(31 downto 0);
begin
    if rising_edge(clk) then
        if (reset = '1') then
            inst_exec_acc <= to_unsigned(0, 32);
            inst_exec_waddr <= to_unsigned(0, 15);
            sp <= to_unsigned(4222, 15);
            inst_exec_in_reset <= '0';
            inst_exec_idst1 <= '0';
            inst_exec_idst0 <= '0';
            inst_exec_write <= '0';
            pc <= to_unsigned(0, 15);
            inst_exec_wreg <= to_unsigned(0, 32);
            inst_exec_idim <= '0';
        else
            inst_exec_idst1 <= inst_exec_vliw(F_HAZ_ST1);
            inst_exec_idst0 <= stdl((inst_exec_vliw(F_WA_MODE) = WA_SP) and bool(inst_exec_vliw(F_IO_WRITE)));
            inst_exec_in_reset <= stdl(state = S_RESET);
            if (state = S_RESET) then
                pc <= to_unsigned(PC_INITADDR, 15);
            elsif ((inst_debug_evt_hold_pc = '0') and ((inst_exec_irqlatch = '0') or (inst_exec_is_im = '1') or (inst_exec_in_exc = '1'))) then
                pc <= inst_exec_nextpc;
            elsif (inst_exec_vliw(F_PC_JMP) = '1') then
                pc <= inst_exec_nextpc;
            end if;
            if ((state = S_EXEC) and (inst_debug_evt_hold = '0')) then
                inst_exec_idim <= inst_exec_is_im;
            elsif (state = S_RESUME) then
                inst_exec_idim <= inst_exec_idim_save;
            elsif (state = S_IRQ) then
                inst_exec_idim <= '0';
            end if;
            if bool(inst_exec_vliw(F_SP_PUSH)) then
                if (not bool(inst_exec_vliw(F_SP_POP))) then
                    if (CONFIG_SP_PUSH_DUP = 1) then
                        sp <= (sp - 1);
                    else
                        sp <= inst_exec_sp_push;
                    end if;
                end if;
            elsif bool(inst_exec_vliw(F_SP_POPSP)) then
                sp <= spval(MEM_ADDR_SLICE);
            elsif bool(inst_exec_vliw(F_SP_POP)) then
                if (CONFIG_SP_POP_DUP = 1) then
                    sp <= (sp + 1);
                else
                    sp <= inst_exec_sp_pop;
                end if;
            end if;
            inst_exec_write <= inst_exec_vliw(F_IO_WRITE);
            if ((inst_exec_vliw(F_WA_MODE) = WA_SP) and bool(inst_exec_vliw(F_SP_PUSH)) and (not bool(inst_exec_vliw(F_SP_POP)))) then
                inst_exec_waddr <= (sp - 1);
            elsif (inst_exec_vliw(F_WA_MODE) = WA_SP) then
                inst_exec_waddr <= sp;
            elsif (inst_exec_vliw(F_WA_MODE) = WA_OFFS) then
                inst_exec_waddr <= (sp + inst_exec_offset);
            elsif (inst_exec_vliw(F_WA_MODE) = WA_INDIR) then
                inst_exec_waddr <= spval(MEM_ADDR_SLICE);
            else
                null;
            end if;
            wrmode := resize(inst_exec_vliw(F_WR_MODE), 17);
            a := inst_exec_wreg;
            if (wrmode = WR_IM) then
                if bool(inst_exec_idim) then
                    inst_exec_wreg <= unsigned'(inst_exec_wreg((32 - 7)-1 downto 0) & unsigned(imm(7-1 downto 0)));
                else
                    inst_exec_wreg <= unsigned(resize(imm, 32));
                end if;
            elsif (wrmode = WR_PC) then
                inst_exec_wreg <= resize(pc, 32);
            elsif (wrmode = WR_SPVAL) then
                inst_exec_wreg <= spval;
            elsif (wrmode = WR_PUSHSP) then
                inst_exec_wreg <= unsigned'(to_unsigned(0, 15) & sp & unsigned'("00"));
            elsif (wrmode = WR_NOT) then
                inst_exec_wreg <= (not spval);
            elsif (wrmode = WR_FLIP) then
                inst_exec_wreg <= MYHDL53_flip(spval);
            elsif (USE_ALU_DELAY = 0) then
                if (wrmode = WR_OR) then
                    inst_exec_wreg <= (a or spval);
                elsif (wrmode = WR_ADD) then
                    inst_exec_wreg <= unsigned(signed(a) + signed(spval));
                elsif (wrmode = WR_AND) then
                    inst_exec_wreg <= (a and spval);
                end if;
            elsif (wrmode = WR_ACC) then
                inst_exec_wreg <= inst_exec_acc;
            end if;
            if (USE_ALU_DELAY = 1) then
                if (wrmode = WR_OR) then
                    inst_exec_acc <= (inst_exec_acc or a);
                elsif (wrmode = WR_ADD) then
                    inst_exec_acc <= unsigned(signed(inst_exec_acc) + signed(a));
                elsif (wrmode = WR_AND) then
                    inst_exec_acc <= (inst_exec_acc and a);
                end if;
            end if;
        end if;
    end if;
end process ZPUNG_INST_EXEC_WORKER;

-- Simple zero latency fetch unit. Slow.
ZPUNG_INST_FETCH_SELECT: process (inst_fetch_mod_d, imem_idata, tap_emuir, pc, inst_debug_evt_emuexec) is
    variable ir32: unsigned(31 downto 0);
begin
    ir32 := imem_idata;
    if (inst_debug_evt_emuexec = '1') then
        insn <= tap_emuir;
    elsif (inst_fetch_mod_d = 0) then
        insn <= ir32(32-1 downto 24);
    elsif (inst_fetch_mod_d = 1) then
        insn <= ir32(24-1 downto 16);
    elsif (inst_fetch_mod_d = 2) then
        insn <= ir32(16-1 downto 8);
    else
        insn <= ir32(8-1 downto 0);
    end if;
    imem_iaddr <= resize(pc(15-1 downto 2), 12);
end process ZPUNG_INST_FETCH_SELECT;


ZPUNG_INST_FETCH_PROCEED: process (clk) is
begin
    if rising_edge(clk) then
        inst_fetch_mod_d <= pc(2-1 downto 0);
    end if;
end process ZPUNG_INST_FETCH_PROCEED;

-- ZPU instruction abstraction ('legacy interpreter')
ZPUNG_INST_DECODE_WORKER: process (insn) is
    variable im: integer;
    variable m: t_enum_t_mode_2;
    variable op: unsigned(7 downto 0);
begin
    m := M_NOP;
    im := to_integer(signed(insn(7-1 downto 0)));
    func <= resize(insn(OPMODE_GEN), 3);
    if (insn(OPMODE_IM) = '1') then
        m := M_IMM;
    elsif (insn(OPMODE_SPLDST) = OP_EMULATE) then
        m := M_EMUINSN;
    elsif (insn(OPMODE_SPLDST) = OP_LOADSP) then
        m := M_LDSP;
    elsif (insn(OPMODE_SPLDST) = OP_STORESP) then
        m := M_STSP;
    elsif (insn(OPMODE_SPOP) = OP_ADDSP) then
        m := M_ADDSP;
    else
        op := resize(insn(OPMODE_GEN), 8);
        case op is
            when "00000000" =>
                m := M_SWBRK;
            when "00000010" =>
                m := M_PUSHSP;
            when "00000100" =>
                m := M_POPPC;
            when "00000101" =>
                m := M_ALU;
            when "00000111" =>
                m := M_ALU;
            when "00000110" =>
                m := M_ALU;
            when "00001000" =>
                m := M_LOAD;
            when "00001001" =>
                m := M_NOT;
            when "00001010" =>
                m := M_FLIP;
            when "00001100" =>
                m := M_STORE;
            when "00001101" =>
                m := M_POPSP;
            when "00001111" =>
                m := M_POPINT;
            when others =>
                m := M_NOP;
        end case;
    end if;
    mode <= m;
    imm <= to_signed(im, 7);
end process ZPUNG_INST_DECODE_WORKER;

-- Debug Logic state machine for three pipeline stage CPU types
ZPUNG_INST_DEBUG_FSM: process (clk, tap_reset) is
begin
    if (tap_reset = '1') then
        inst_debug_state <= S_RUN;
        inst_debug_evt_toggle_emu <= '0';
        inst_debug_swbreak <= '0';
        inst_debug_evt_emuexec <= '0';
    elsif rising_edge(clk) then
        inst_debug_evt_toggle_emu <= '0';
        case inst_debug_state is
            when S_RUN =>
                if ((tap_emureq = '1') or (inst_debug_evt_brk = '1')) then
                    if ((not bool(inst_debug_emumask)) or bool(inst_debug_evt_brk)) then
                        inst_debug_state <= S_EMUACK;
                        inst_debug_evt_toggle_emu <= '1';
                    end if;
                    if bool(inst_debug_evt_brk) then
                        inst_debug_swbreak <= '1';
                    end if;
                end if;
            when S_EMUACK =>
                if (inst_debug_busy = '0') then
                    inst_debug_state <= S_EMULATION;
                end if;
            when S_RESUME =>
                inst_debug_evt_toggle_emu <= '1';
                inst_debug_state <= S_RUN;
            when S_EMUEXEC =>
                if bool(inst_debug_evt_brk) then
                    inst_debug_state <= S_RESUME;
                    inst_debug_swbreak <= '0';
                elsif (inst_debug_busy = '0') then
                    inst_debug_state <= S_EMUACK;
                end if;
            when others => -- S_EMULATION
                if (inst_debug_evt_reset = '1') then
                    inst_debug_swbreak <= '0';
                end if;
                if (tap_emuexec = '1') then
                    inst_debug_state <= S_EMUEXEC;
                end if;
        end case;
        inst_debug_evt_emuexec <= stdl(bool(tap_emuexec) and (inst_debug_state = S_EMULATION));
    end if;
end process ZPUNG_INST_DEBUG_FSM;


ZPUNG_INST_DEBUG_ASSIGN: process (inst_debug_evt_busy, inst_debug_state, tap_emureq, tap_emumask, inst_debug_evt_cpustat, inst_debug_swbreak, inst_debug_evt_emumask, tap_emuexec) is
    variable ack: std_logic;
    variable t: std_logic;
begin
    ack := stdl((inst_debug_state = S_EMUACK) or (inst_debug_state = S_EMULATION) or (inst_debug_state = S_EMUEXEC));
    tap_exstat <= inst_debug_evt_cpustat;
    tap_emuack <= ack;
    inst_debug_evt_emuack <= ack;
    inst_debug_evt_dbgbreak <= inst_debug_swbreak;
    tap_emurdy <= stdl(inst_debug_state = S_EMULATION);
    inst_debug_evt_hold <= stdl(((inst_debug_state = S_EMULATION) or (inst_debug_state = S_EMUACK)) and (not bool(tap_emuexec)));
    t := stdl(bool(inst_debug_evt_emumask) and bool(tap_emumask));
    inst_debug_emumask <= t;
    inst_debug_evt_hold_pc <= stdl(bool(tap_emureq) and (not (inst_debug_state = S_RESUME)) and (not bool(t)));
    inst_debug_busy <= stdl(bool(inst_debug_evt_busy) or bool(t));
end process ZPUNG_INST_DEBUG_ASSIGN;


ZPUNG_INST_MEMMGR_SELECT: process (inst_memmgr_pa_we, mmr_busy, inst_memmgr_dmem_d, inst_memmgr_sb_rdata, mmr_rdata, inst_memmgr_pa_wdata, inst_memmgr_iomem_d, imem_rdata, inst_memmgr_pa_addr, inst_memmgr_pb_addr) is
begin
    mmr_wdata <= inst_memmgr_pa_wdata;
    imem_wdata <= inst_memmgr_pa_wdata;
    mmr_addr <= inst_memmgr_pb_addr;
    imem_daddr <= inst_memmgr_pb_addr((MEM_W - 2)-1 downto 0);
    iobusy <= mmr_busy;
    if (MYHDL62_is_mmr(inst_memmgr_pb_addr) = '1') then
        mmr_re <= '1';
        imem_read <= '0';
    elsif (MYHDL63_is_dmem(inst_memmgr_pb_addr) = '1') then
        imem_read <= '1';
        mmr_re <= '0';
    else
        imem_read <= '0';
        mmr_re <= '0';
    end if;
    if (MYHDL64_is_mmr(inst_memmgr_pa_addr) = '1') then
        imem_write <= '0';
        mmr_we <= inst_memmgr_pa_we;
        if (inst_memmgr_pa_we = '1') then
            mmr_addr <= inst_memmgr_pa_addr;
        end if;
        inst_memmgr_sa_we <= '0';
    elsif (MYHDL65_is_dmem(inst_memmgr_pa_addr) = '1') then
        imem_write <= inst_memmgr_pa_we;
        mmr_we <= '0';
        if (inst_memmgr_pa_we = '1') then
            imem_daddr <= resize(inst_memmgr_pa_addr((ADDR_W - 2)-1 downto 0), 12);
        end if;
        inst_memmgr_sa_we <= '0';
    else
        imem_write <= '0';
        mmr_we <= '0';
        inst_memmgr_sa_we <= inst_memmgr_pa_we;
    end if;
    if (inst_memmgr_iomem_d = '1') then
        inst_memmgr_pb_rdata <= mmr_rdata;
    elsif (inst_memmgr_dmem_d = '1') then
        inst_memmgr_pb_rdata <= imem_rdata;
    else
        inst_memmgr_pb_rdata <= inst_memmgr_sb_rdata;
    end if;
    inst_memmgr_sa_addr <= inst_memmgr_pa_addr(STACKMEM_WIDTH-1 downto 0);
    inst_memmgr_sa_wdata <= inst_memmgr_pa_wdata;
    inst_memmgr_sb_addr <= inst_memmgr_pb_addr(STACKMEM_WIDTH-1 downto 0);
end process ZPUNG_INST_MEMMGR_SELECT;


ZPUNG_INST_MEMMGR_INST_STACK_WORK: process (clk) is
begin
    if rising_edge(clk) then
        if ((inst_memmgr_sa_we = '1') and (inst_memmgr_sa_addr = inst_memmgr_sb_addr)) then
            inst_memmgr_inst_stack_data <= inst_memmgr_sa_wdata;
        else
            inst_memmgr_inst_stack_data <= inst_memmgr_inst_stack_ram(to_integer(inst_memmgr_sb_addr));
        end if;
        if (inst_memmgr_sa_we = '1') then
            
            inst_memmgr_inst_stack_ram(to_integer(inst_memmgr_sa_addr)) <= inst_memmgr_sa_wdata;
        end if;
    end if;
end process ZPUNG_INST_MEMMGR_INST_STACK_WORK;



inst_memmgr_sb_rdata <= inst_memmgr_inst_stack_data;


ZPUNG_INST_MEMMGR_LDDELAY: process (clk) is
begin
    if rising_edge(clk) then
        inst_memmgr_dmem_d <= MYHDL69_is_dmem(inst_memmgr_pb_addr);
        if (iobusy = '0') then
            inst_memmgr_iomem_d <= MYHDL70_is_mmr(inst_memmgr_pb_addr);
        end if;
    end if;
end process ZPUNG_INST_MEMMGR_LDDELAY;



tap_curpc <= resize(pc, 32);
tap_odata <= spval;
evt_override <= override;
evt_cache_wait <= cache_wait;

end architecture MyHDL;
