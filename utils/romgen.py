# ROM generation utility
# (c) section5.ch
#
# This file contains auxiliary classes to generate a RAM layout from
# ELF code in various binary formats. The output is currently in
# VHDL format.
#
# Supported architectures:
#
# * ZPU (primary support)
# * MIPS, RISCV and other compatibles
#
import elf
import intelhex

#Sections to ignore
MSG = " section %16s Addr: %08x len %d"
LOADTXT = "Load" + MSG
SKIPTXT = "Skipping" + MSG

HEADER = """----------------------------------------------------------------
--    This is a file generated by romgen.py
--
--    Changes to this file will be void.

-- Length: %d
-- Start at: 0x%08x
----------------------------------------------------------------------------\n"""

def write_imem(memory, data, addr):
	ds = ">L"
	l = len(data)
	i = 0
	c = addr & 0xffff
	m = l % 4
	if m:
		m = 4-m
		data += "\0" * m
		l += m


	while i < l:
		chunk = data[i:i+4]
		words = elf.struct.unpack(ds, chunk)
		# print "Write %x <- %08x" % (c, words[0])
		memory[c] = words[0]
		c += 1
		i += 4

	return c

def write_imem2(memA, memB, data, addr):
	ds = ">H"
	l = len(data)
	i = 0
	c = addr & 0xffff
	m = l % 2
	if m:
		m = 2-m
		data += "\0" * m
		l += m

	while i < l:
		chunk = data[i:i+2]
		words = elf.struct.unpack(ds, chunk)
		print "Write LWORD %x <- %08x" % (c, words[0])
		memA[c] = words[0]
		i += 2

		chunk = data[i:i+2]
		words = elf.struct.unpack(ds, chunk)
		print "Write UWORD %x <- %08x" % (c, words[0])
		memB[c] = words[0]

		i += 2
		c += 1

	return c

class Romgen_AllData:
	def __init__(self, isize, dsize):
		self.data = intelhex.IntelHex()

	def write_segment(self, addr, data):
		self.data.puts(addr, data)

	def dump(self, data):
		ds = ">I"

		f = open(self.fname, "w")

		l = len(data)

		i = 4 - (l % 4)
		# Pad if necessary:
		data += i * chr(0)
		l += i

		s = ["", "", "", ""]
		i = 0
		c = 0
		while (i < l):
			chunk = data[i:i+4]
			words = elf.struct.unpack(ds, chunk)
			f.write('x"%08x",' % words[0])
			c += 1
			i += 4
			if c == 4:
				c = 0
				f.write('\n')

		f.write('others => x"00000000"\n')
		f.close()

	def to_buffer(self):
		return self.data.tobinstr()

	def finish(self):
		data = self.data.tobinstr()
		self.dump(data)

	def dump_hex(self, prefix):
		ds = ">L"
		data = self.data.tobinstr()

		l = len(data)
		i = 0

		hexfile = open(prefix + "32.hex", "w")

		s = ""
		while (i < l):
			chunk = data[i:i+4]
			words = elf.struct.unpack(ds, chunk)
			s += '%08x\n' % words
			i += 4

		hexfile.write(s)
		hexfile.close()

class Romgen_ProgData:
	PROG_SECTIONS = [".text", ".init", ".fixed_vectors" ]
	DATA_SECTIONS = [ ".rodata", ".data" ]

	def __init__(self, isize, dsize):
		self.text = intelhex.IntelHex()
		self.data = intelhex.IntelHex()

	def write_dataseg(self, addr, data):
		self.data.puts(addr, data)

	def write_textseg(self, addr, data):
		self.text.puts(addr, data)

	def handle(self, p):
		l = len(p.data)
		if p.name in self.PROG_SECTIONS:
			self.write_textseg(p.sh_addr, p.data)
			print LOADTXT % (p.name, p.sh_addr, l)
		elif p.name in self.DATA_SECTIONS:
			self.write_dataseg(p.sh_addr, p.data)
			print LOADTXT % (p.name, p.sh_addr, l)
		else:
			print SKIPTXT % (p.name, p.sh_addr, len(p.data))

	def finish(self):
		print 20 * "-" + " TEXT " + 20 * "-"
		self.text.dump()
		print 20 * "-" + " DATA " + 20 * "-"
		self.data.dump()

class Romgen_ZPU(Romgen_AllData):
	PROG_SECTIONS = [".text", ".l1.text", ".l2.text", ".init",
	".fixed_vectors" ]
	DATA_SECTIONS = [ ".rodata", ".rodata.str1.4", ".data",
	".ctors", ".dtors" ]

	def __init__(self, prefix):
		self.data = intelhex.IntelHex()
		self.fname = prefix + "_data.tmp"

	def handle(self, p):
		l = len(p.data)
		if p.name in self.PROG_SECTIONS:
			self.write_segment(p.sh_addr, p.data)
			print LOADTXT % (p.name, p.sh_addr, l)
		elif p.name in self.DATA_SECTIONS:
			self.write_segment(p.sh_addr, p.data)
			print LOADTXT % (p.name, p.sh_addr, l)
		else:
			print SKIPTXT % (p.name, p.sh_addr, l)


class Romgen_imem_dmem:
	"Produces separate I and D memory files"
	def __init__(self, template, size = 2):
		self.textfile = open(template + "_text.tmp", "w")
		self.datafile = open(template + "_data.tmp", "w")

		self.text = intelhex.IntelHex()
		self.data = intelhex.IntelHex()
		self.size = size
		self.endian = ">"
		self.text_offset = 0x0000
		self.data_offset = 0xc000

	def write_data(self, fdata, data):
		size = self.size
		n = size >> 1
		ds = self.endian + n * 'H'
		l = len(data)
		i = 0
		c = 0

		self.datafile.write(HEADER % (l, self.data_offset))

		while (i < l):
			chunk = data[i:i+size]
			words = elf.struct.unpack(ds, chunk)

			fdata.write('x"%04x",' % words[0])
			i += size
			c += 1
			if c == 8:
				c = 0
				fdata.write('\n')

		if l == 0:
			fdata.write('others => ( others => x"0000")\n')
			return 0
			

		return l

	def write_text(self, data):
		size = self.size
		n = size >> 1
		ds = self.endian + n * 'H'
		l = len(data)
		i = 0
		c = 0

		self.textfile.write(HEADER % (l, self.text_offset))
		self.textfile.write('-- Length: %d\n' % l)
		self.textfile.write('-- Offset: %08x\n' % self.text_offset)
	
		while (i < l):
			chunk = data[i:i+size]
			words = elf.struct.unpack(ds, chunk)
			self.textfile.write('x"%04x",' % words[0])
			c += 1
			i += size
			if c == 8:
				c = 0
				self.textfile.write('\n')

		self.textfile.write('\n')

		return l

	def write_text_segment(self, addr, data):
		self.text.puts(addr, data)
		if addr < self.text_offset:
			self.text_offset = addr

	def write_data_segment(self, addr, data):
		self.data.puts(addr, data)
		if addr < self.data_offset:
			self.data_offset = addr

	def finish(self):
		data = self.text.tobinstr(self.text_offset)
		self.write_text(data)
		data = self.data.tobinstr(self.data_offset)
		self.write_data(self.datafile, data)
		self.datafile.close()
		self.textfile.close()

	def dump_hex(self, prefix):
		print "Warning, dump_hex for neo430 not yet implemented"
		return False

def pad(data, n):
	m = len(data) % n
	if m != 0:
		n -= m
		print "Warning: padding with %d bytes" % n
		data += n * b'\0'
	return data

class Romgen_Mem2x16i_4x8d:
	def __init__(self, template):
		self.fl = open(template + "_iram_l.tmp", "w")
		self.fh = open(template + "_iram_h.tmp", "w")
		self.fda = open(template + "_dram_a.tmp", "w")
		self.fdb = open(template + "_dram_b.tmp", "w")
		self.text = intelhex.IntelHex()
		self.data_a = intelhex.IntelHex()
		self.data_b = intelhex.IntelHex()
		self.endian = ">"

	def write_data(self, fdata, data):
		ds = ">BBBB"
		l = len(data)
		i = 0
		c = 0

		fdata.write('-- Length: %d\n' % l)
		if l == 0:
			fdata.write('others => ( others => x"0000")\n')
			return 0
			

		s = ["", "", "", ""]
		while (i < l):
			chunk = data[i:i+4]
			words = elf.struct.unpack(ds, chunk)
			for j in range(4):
				s[j] += 'x"%04x",' % words[j]
			c += 1
			i += 4
			if c == 8:
				c = 0
				for j in range(4):
					s[j] += '\n'

		for j in range(4):
			s[j] += '\n'

		for j in range(4):
			fdata.write("\n    --- Byte %d ---\n" % j)
			fdata.write("(\n")
			fdata.write(s[j])
			fdata.write('others => x"0000"\n')
			if j == 3:
				fdata.write(")\n")
			else:
				fdata.write("),\n")

		return l

	def write_text(self, data):
		ds = self.endian + "HH"
		l = len(data)
		i = 0
		c = 0
		
		while (i < l):
			chunk = data[i:i+4]
			words = elf.struct.unpack(ds, chunk)
			self.fh.write('x"%04x",' % words[0])
			self.fl.write('x"%04x",' % words[1])
			c += 1
			i += 4
			if c == 8:
				c = 0
				self.fh.write('\n')
				self.fl.write('\n')

		self.fh.write('\n')
		self.fl.write('\n')

		return l

	def finish(self):
		data = self.text.tobinstr()
		data = pad(data, 4)
		self.write_text(data)
		data = self.data_a.tobinstr()

		data = pad(data, 4)
		self.write_data(self.fda, data)
		data = self.data_b.tobinstr()
		data = pad(data, 4)
		self.write_data(self.fdb, data)

		self.fh.write('others => x"0000"\n')
		self.fl.write('others => x"0000"\n')
		self.fl.close()
		self.fh.close()
		self.fda.close()
		self.fdb.close()

	def dump_byte_hex(self, prefix, data):
		ds = ">BBBB"
		l = len(data)
		i = 0
		s = ["", "", "", ""]
		while (i < l):
			chunk = data[i:i+4]
			words = elf.struct.unpack(ds, chunk)
			for j in range(4):
				s[j] += '%02x\n' % words[j]
			i += 4

		for j in range(4):
			fdata = open(prefix + "_data_b%d.hex" % j, "w")
			fdata.write(s[j])
			fdata.close()

		return l

	def dump_hex(self, prefix):
		low = open(prefix + "_l.hex", "w")
		high = open(prefix + "_h.hex", "w")
		data = self.text.tobinstr()

		ds = "<HH"
		l = len(data)
		i = 0

		s = ["", ""]
		while (i < l):
			chunk = data[i:i+4]
			words = elf.struct.unpack(ds, chunk)
			for j in range(2):
				s[j] += '%04x\n' % words[j]
			i += 4

		low.write(s[0])
		high.write(s[1])

		low.close()
		high.close()

		a = self.data_a.tobinstr()
		a = pad(a, 4)
		self.dump_byte_hex(prefix, a)

class Romgen_MIPS(Romgen_Mem2x16i_4x8d):
	"MIPS/RISCV style memory layout"
	PROG_SECTIONS = [".text", ".init", ".fixed_vectors" ]
	DATA_SECTIONS_A = [ ".l1data", ".l1data.a", '.rodata' ]
	DATA_SECTIONS_B = [ ".l1data.b", ".scratchpad" ]

	def __init__(self, prefix):
		Romgen_Mem2x16i_4x8d.__init__(self, prefix)
		self.endian = ">"

	def handle(self, p):
		l = len(p.data)
		if p.name in self.PROG_SECTIONS:
			self.text.puts(p.sh_addr, p.data)
			print LOADTXT % (p.name, p.sh_addr, l)
		elif p.name in self.DATA_SECTIONS_A:
			self.data_a.puts(p.sh_addr, p.data)
			print LOADTXT % (p.name, p.sh_addr, l)
		elif p.name in self.DATA_SECTIONS_B:
			self.data_b.puts(p.sh_addr, p.data)
			print LOADTXT % (p.name, p.sh_addr, l)
		else:
			print SKIPTXT % (p.name, p.sh_addr, len(p.data))


	def to_buffer(self):
		return (self.text.tobinstr(), \
			self.data_a.tobinstr(), self.data_b.tobinstr())

class Romgen_RISCV(Romgen_MIPS):
	"MIPS/RISCV style memory layout"
	PROG_SECTIONS = [".text", ".init", ".fixed_vectors" ]
	DATA_SECTIONS_A = [ ".l1data", ".l1data.a", '.rodata',
	'.data', '.sdata', '.srodata' ]
	DATA_SECTIONS_B = [ ".l1data.b", ".scratchpad" ]

	def __init__(self, prefix):
		Romgen_Mem2x16i_4x8d.__init__(self, prefix)
		self.endian = "<"


class Romgen_MSP430(Romgen_imem_dmem):
	IMEM_SECTIONS = [".text", ".l1.text", ".l2.text", ".init",  \
		".rodata", ".rodata.str1.4", ".fixed_vectors" ]
	DMEM_SECTIONS = [ ".data", ".ctors", ".dtors" ]

	def __init__(self, prefix):
		Romgen_imem_dmem.__init__(self, prefix)
		self.endian = "<"

	def handle(self, p):
		l = len(p.data)
		if p.name in self.IMEM_SECTIONS:
			self.write_text_segment(p.sh_addr, p.data)
			print LOADTXT % (p.name, p.sh_addr, l)
		elif p.name in self.DMEM_SECTIONS:
			self.write_data_segment(p.sh_addr, p.data)
			print LOADTXT % (p.name, p.sh_addr, l)
		else:
			print SKIPTXT % (p.name, p.sh_addr, l)



############################################################################

def load_elf_zpu(e, imemory, dmemory, debug = None):
	"ZPU ELF format loader"

	romgen = Romgen_ZPU("zpu")
	IGNORE_SECTIONS = []

	for p in e.sections:
		if p.sh_flags & (elf.ELFSection.SHF_WRITE | 
						 elf.ELFSection.SHF_EXECINSTR |
						 elf.ELFSection.SHF_ALLOC):

			if p.name not in IGNORE_SECTIONS:
				romgen.handle(p)
		elif debug:
			print "Dropping '%s' at %08x, len: %d" % \
				(p.name, p.sh_addr, len(p.data))

	return romgen

def load_elf_riscv32(e, imemory, dmemory, debug = None):
	"RISCV32 ELF format loader"
	DATA_SECTIONS = [ ".data", ".sdata", ".rodata", ".srodata" ]

	romgen = Romgen_RISCV("rv32")

	for p in e.sections:
		if p.sh_flags & (elf.ELFSection.SHF_WRITE | 
                         elf.ELFSection.SHF_EXECINSTR |
		                 elf.ELFSection.SHF_ALLOC):

			romgen.handle(p)
		elif debug:
			print "Dropping '%s' at %08x, len: %d" % \
				(p.name, p.sh_addr, len(p.data))

	return romgen

############################################################################
# Known 32 bit ELF files to parse:

KNOWN_MACHINES = {
	0x6a: (load_elf_zpu,     'ZPU'),
	0xf3: (load_elf_riscv32, 'RISCV32')
}

def open_elf(infile):
	e = elf.ELFObject()
	f = open(infile)
	e.fromFile(f)
	f.close()
	return e


def load_elf(elffile, imemory = None, dmemory = None):

	e = open_elf(elffile)
	if e.e_machine not in KNOWN_MACHINES.keys():
		raise TypeError, "Unsupported executable format code %02x" \
			% (e.e_machine)

	handler = KNOWN_MACHINES[e.e_machine][0]
	romgen = handler(e, imemory, dmemory)

	if imemory == None:
		ret = romgen.to_buffer()
	elif type(imemory) == type(()):
		romgen.dump2(imemory[0], imemory[1])
		ret = None
	else:
		romgen.dump(imemory)
		ret = None

	return ret

def load_symbols(elffile):
	e = open_elf(elffile)
	return e.parseSymbols()
